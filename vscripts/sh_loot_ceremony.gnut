#if SERVER
global function LootBoxCeremony_Init
#endif


#if CLIENT
global function CLLootBoxCeremony_Init
global function UIToClient_LootCeremony_SetMenuHandles
global function UIToClient_EnterLootCeremony
global function UIToClient_AdditionalLootTick_Sequence
global function UIToClient_LootCeremonyExit
global function UIToClient_RewardPlacard_Hover
global function UIToClient_RewardInspectActivate
global function UIToClient_RewardInspectNavBack
global function UIToClient_RewardEquipOnClick
global function UIToClient_RewardEquipOnClickWithIndex
global function UIToClient_RewardEquipToWheelOnClick
global function UIToClient_RewardEquipToWheelOnClickWithIndex
global function UIToClient_OnGRXPackOpeningResultsAvailable
global function UIToClient_SkipAnimation

global function UIToClient_SpecialItemPresentation
global function UIToClient_SpecialItemPresentationExit

global function IsLootCeremonyActive
global function IsSpecialItemPresentationModeActive

global function ModelIntroHighlightEffect
#endif


#if CLIENT && R5DEV
global function DEV_ShouldShowCustomLootRewards
global function DEV_SetCustomLootRewardsToDisplay
#endif


#if UI
global function InitLootBoxMenu
global function OnLobbyOpenLootBoxMenu_ButtonPress

global function ClientToUI_UpdateSpecialItemPresentationPurchaseButton
global function ClientToUI_EquipButtonShowDialog
global function ClientToUI_EquipToWheelButtonShowDialog
global function ClientToUI_SetLootHasBeenPresented
global function ClientToUI_SetInspectModeIsActive
global function ClientToUI_ClearInspectModeIsActive
global function ClientToUI_PlayLootCeremonySound
global function ClientToUI_StopLootCeremonySound
global function ClientToUI_LootCeremonyMarkItemAsNoLongerNew

global function LootCeremony_UpdateOpenAdditionalButton

global function InspectItemTypePresentationSupported
global function SetStoreItemPresentationModeActive
global function SetBattlePassItemPresentationModeActive
global function SetGenericItemPresentationModeActive
global function SetCollectionEventItemPresentationModeActive
global function SetChallengeRewardPresentationModeActive
global function GetNextLootBox
#endif

#if CLIENT || UI 
global function TEMP_GetVoidwalkerBundle
#endif

global const string LOOT_CEREMONY_MUSIC_P1 = "Music_LootCeremony_Pt1"
global const string LOOT_CEREMONY_MUSIC_P2 = "Music_LootCeremony_Pt2"

#if SERVER || CLIENT
const float CAMERA_FOV = 35.5

const asset TICK_MODEL_DEFAULT = $"mdl/robots/drone_frag/drone_frag_loot.rmdl"
const asset TICK_FX_HOLO_BEAM_BASE = $"P_loot_triad_beam"
const asset TICK_FX_HOLO_BEAM_TIER1 = $"P_loot_triad_beam_reveal_T1"
const asset TICK_FX_HOLO_BEAM_TIER2 = $"P_loot_triad_beam_reveal_T2"
const asset TICK_FX_HOLO_BEAM_TIER3 = $"P_loot_triad_beam_reveal_T3"
const asset TICK_FX_HOLO_BEAM_TIER4 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_HOLO_BEAM_TIER5 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_RARITY_IDLE = $"P_loot_tick_beam_idle_flash"
const asset TICK_FX_RARITY_BEAM_TIER1 = $"P_loot_tick_rarity_beam_T1"
const asset TICK_FX_RARITY_BEAM_TIER2 = $"P_loot_tick_rarity_beam_T2"
const asset TICK_FX_RARITY_BEAM_TIER3 = $"P_loot_tick_rarity_beam_T3"
const asset TICK_FX_RARITY_BEAM_TIER4 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_BEAM_TIER5 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_FLASH_TIER1 = $"P_loot_tick_rarity_body_T1"
const asset TICK_FX_RARITY_FLASH_TIER2 = $"P_loot_tick_rarity_body_T2"
const asset TICK_FX_RARITY_FLASH_TIER3 = $"P_loot_tick_rarity_body_T3"
const asset TICK_FX_RARITY_FLASH_TIER4 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_RARITY_FLASH_TIER5 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_HEAD_CHARGE = $"P_loot_tick_head_charge"
const asset TICK_FX_JUMP_JET = $"P_loot_tick_jump_jet"
const string ATTACHNAME_LEFT = "FX_L_EYE"
const string ATTACHNAME_CENTER = "FX_R_EYE"        //
const string ATTACHNAME_RIGHT = "FX_C_EYE"        //
const array<string> TICK_LOOT_ATTACHMENTS = [ ATTACHNAME_LEFT, ATTACHNAME_CENTER, ATTACHNAME_RIGHT ]
const array<string> INSPECT_BUTTONS = [ "RewardLeftButton", "RewardCenterButton", "RewardRightButton" ]

global const asset CURRENCY_MODEL_COMMON = $"mdl/currency/crafting/currency_crafting_common.rmdl"
global const asset CURRENCY_MODEL_RARE = $"mdl/currency/crafting/currency_crafting_rare.rmdl"
global const asset CURRENCY_MODEL_EPIC = $"mdl/currency/crafting/currency_crafting_epic.rmdl"
global const asset CURRENCY_MODEL_LEGENDARY = $"mdl/currency/crafting/currency_crafting_legendary.rmdl"
const asset QUIP_BG_MODEL = $"mdl/menu/loot_ceremony_quip_bg.rmdl"
const asset STAT_TRACKER_BG_MODEL = $"mdl/menu/loot_ceremony_stat_tracker_bg.rmdl"

const asset FINISHER_SWAP_FX = $"P_menu_finisher_swap"

const string SOUND_DEPLOY_ZOOM = "LootCeremony_Tick_Deploy_Zoom"
const string SOUND_LIGHT_FLASH = "LootCeremony_Tick_LightFlash"
const string SOUND_BEAM_SWEETEN_TIER1 = "LootCeremony_Tick_Deploy_BeamSweetener_Rare"
const string SOUND_BEAM_SWEETEN_TIER2 = "LootCeremony_Tick_Deploy_BeamSweetener_Epic"
const string SOUND_BEAM_SWEETEN_TIER3 = "LootCeremony_Tick_Deploy_BeamSweetener_Legendary"
const string SOUND_BEAM_SWEETEN_TIER4 = "LootCeremony_Tick_Deploy_BeamSweetener_Heirloom"
const string SOUND_HOLOGRAM_FIRST_APPEAR = "LootCeremony_LootHologram_FirstAppear"
const string SOUND_HOLOGRAM_LOOP = "LootCeremony_Inspect_HologramLoop"
const string SOUND_HOLOGRAM_APPEAR_TIER0 = "LootCeremony_LootHologram_Appear_Common"
const string SOUND_HOLOGRAM_APPEAR_TIER1 = "LootCeremony_LootHologram_Appear_Rare"
const string SOUND_HOLOGRAM_APPEAR_TIER2 = "LootCeremony_LootHologram_Appear_Epic"
const string SOUND_HOLOGRAM_APPEAR_TIER3 = "LootCeremony_LootHologram_Appear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_TIER4 = "LootCeremony_LootHologram_Appear_Heirloom"
const string SOUND_INSPECT_ZOOM_IN = "LootCeremony_Inspect_ZoomIn"
const string SOUND_INSPECT_ZOOM_OUT = "LootCeremony_Inspect_ZoomOut"
const string SOUND_EQUIP = "UI_Menu_Equip_Generic"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER3 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER4 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_RESETVIEW = "LootCeremony_LootHologram_Appear_ResetView"
#endif


#if CLIENT
struct ItemPresentationData
{
	ItemFlavor& item
	string      attachment
	int         rarity
	int         quantity = 1
}
#endif


#if CLIENT
struct DummyInspectButtonData
{
	var  button
	bool shouldShow
}
#endif


#if CLIENT
struct GladiatorCardData
{
	NestedGladiatorCardHandle& handle
	var                        rui
	var                        topo = null
}
#endif


#if UI
struct FileForeverStruct
{
	table signalDummy

	var menu
	var inspectMenu
	var equipButton
	var equipToWheelButton
	var purchaseButton
	var mouseClickElem
	var inspectVideoPanel
	var storeButton
	var lootBoxOpenButton
	var inspectRewardButton1
	var inspectRewardButton2
	var inspectRewardButton3
	var skipAnimButton
	var blackFlash
}
FileForeverStruct& fileForever
#endif


enum eCeremonyPresentationMode
{
	APEX_PACK,
	STORE_ITEM,
	BATTLE_PASS,
}

struct FileLevelStruct
{
	#if SERVER
	#endif

	#if CLIENT
		table  signalDummy

		var                           menu
		var                           inspectMenu
		var                           equipButton
		var                           equipToWheelButton
		var                           purchaseButton
		ItemFlavor&                   equipButtonItemFlavor
		var                           mouseClickElem
		var                           inspectVideoPanel
		array<DummyInspectButtonData> dummyInspectButtons
		var                           skipAnimButton
		bool                          menuActive = false
		bool                          inspectMenuIsNavigatingBack = false

		entity lootTickMover
		entity lootTickModel
		entity cameraMover
		entity cameraEnt

		table<string, var>            rewardPlacards = { RewardLeftButton = null, RewardCenterButton = null, RewardRightButton = null }
		array< ItemPresentationData > itemPresentationDatas

		bool specialItemPresentationModeActive = false

		int presentationMode = eCeremonyPresentationMode.APEX_PACK

		// grx
		ItemFlavor& currentPackFlav
		bool        grxRewardsReceived = false

		// fx
		array<int> rarityBeamFXHandles
		bool       tickRandomFlashFXStarted = false

		array<PakHandle> pakHandles
	#endif

	#if CLIENT && R5DEV
		bool           debugShowCustomRewards = false
		array< asset > debugCustomRewardAssets = [
			$"settings/itemflav/character_skin/wraith/legendary_01.rpak",
			$"settings/itemflav/gcard_stance/wraith/epic_05.rpak",
			$"settings/itemflav/weapon_skin/hemlok/rare_04.rpak"
		]
	#endif

	#if UI
		ItemFlavor ornull       forceParticularPackFlav = null
		bool                    lootHasBeenPresented = false
		bool                    considerFocusOpenButton = false
		bool                    inspectModeActive = false
		bool                    specialItemPresentationModeActive = false
		GRXScriptOffer ornull   storeItemPresentationModeOffer
		ItemFlavor&             specialItemPresentationModeItemFlav
		int                     specialItemPresentationModeItemQty
		ItemFlavor ornull       storeItemPresentationModeItemPrereq = null
		string                  specialItemFormattedPrice = ""
		bool ornull             specialItemOverrideOwned = null
		bool                    specialItemHideEquipButton = false
		bool                    specialItemHidePurchaseButton = false
		string                  specialItemPriceHeader = ""
		bool                    specialItemLockPurchaseButton = false
		string ornull           specialItemPackName = null
		asset ornull            specialItemPackImg = null
	#endif
}
FileLevelStruct& fileLevel


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//   ######  ######## ########  ##     ## ######## ########     #### ##    ## #### ########
//  ##    ## ##       ##     ## ##     ## ##       ##     ##     ##  ###   ##  ##     ##
//  ##       ##       ##     ## ##     ## ##       ##     ##     ##  ####  ##  ##     ##
//   ######  ######   ########  ##     ## ######   ########      ##  ## ## ##  ##     ##
//        ## ##       ##   ##    ##   ##  ##       ##   ##       ##  ##  ####  ##     ##
//  ##    ## ##       ##    ##    ## ##   ##       ##    ##      ##  ##   ###  ##     ##
//   ######  ######## ##     ##    ###    ######## ##     ##    #### ##    ## ####    ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if SERVER
void function LootBoxCeremony_Init()
{
	PrecacheModel( TICK_MODEL_DEFAULT )
	PrecacheModel( CURRENCY_MODEL_COMMON )
	PrecacheModel( CURRENCY_MODEL_RARE )
	PrecacheModel( CURRENCY_MODEL_EPIC )
	PrecacheModel( CURRENCY_MODEL_LEGENDARY )
	PrecacheModel( QUIP_BG_MODEL )
	PrecacheModel( STAT_TRACKER_BG_MODEL )

	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_BASE )
	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_TIER1 )
	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_TIER2 )
	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_TIER3 )
	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_TIER4 )
	PrecacheParticleSystem( TICK_FX_HOLO_BEAM_TIER5 )
	PrecacheParticleSystem( TICK_FX_RARITY_IDLE )
	PrecacheParticleSystem( TICK_FX_RARITY_BEAM_TIER1 )
	PrecacheParticleSystem( TICK_FX_RARITY_BEAM_TIER2 )
	PrecacheParticleSystem( TICK_FX_RARITY_BEAM_TIER3 )
	PrecacheParticleSystem( TICK_FX_RARITY_BEAM_TIER4 )
	PrecacheParticleSystem( TICK_FX_RARITY_BEAM_TIER5 )
	PrecacheParticleSystem( TICK_FX_RARITY_FLASH_TIER1 )
	PrecacheParticleSystem( TICK_FX_RARITY_FLASH_TIER2 )
	PrecacheParticleSystem( TICK_FX_RARITY_FLASH_TIER3 )
	PrecacheParticleSystem( TICK_FX_RARITY_FLASH_TIER4 )
	PrecacheParticleSystem( TICK_FX_RARITY_FLASH_TIER5 )
	PrecacheParticleSystem( TICK_FX_HEAD_CHARGE )
	PrecacheParticleSystem( TICK_FX_JUMP_JET )
	PrecacheParticleSystem( FINISHER_SWAP_FX )
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//   ######  ##       #### ######## ##    ## ########    #### ##    ## #### ########
//  ##    ## ##        ##  ##       ###   ##    ##        ##  ###   ##  ##     ##
//  ##       ##        ##  ##       ####  ##    ##        ##  ####  ##  ##     ##
//  ##       ##        ##  ######   ## ## ##    ##        ##  ## ## ##  ##     ##
//  ##       ##        ##  ##       ##  ####    ##        ##  ##  ####  ##     ##
//  ##    ## ##        ##  ##       ##   ###    ##        ##  ##   ###  ##     ##
//   ######  ######## #### ######## ##    ##    ##       #### ##    ## ####    ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if CLIENT
void function CLLootBoxCeremony_Init()
{
	RegisterSignal( "LootCeremonyExit" )
	RegisterSignal( "LootCeremonyAnimSeqStart" )
	RegisterSignal( "LootCeremonyInspectModeStart" )
	RegisterSignal( "LootCeremonyInspectModeStartComplete" )
	RegisterSignal( "LootCeremonyInspectModeEnd" )
	RegisterSignal( "LootCeremonyInspectModeEndComplete" )
	RegisterSignal( "LootCeremonyInspectCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectTimeCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectVideoCompleteOrBackout" )
	RegisterSignal( "LootCeremonyTimeComplete" )
	RegisterSignal( "LootCeremonyVideoComplete" )
	RegisterSignal( "TickAnimStartDisplayLoot" )
	RegisterSignal( "TickAnimStartDeployment" )
	RegisterSignal( "TickAnimSkip" )
	RegisterSignal( "LootCeremonyAnimShowLootOrSkip" )
	RegisterSignal( "LootCeremonyTickCancelAnim" )

	LootCeremonyLightingRigPreCache()

	AddCallback_FullUpdate( LootCeremonyOnFullUpdate )
	AddCallback_EntitiesDidLoad( EntitiesDidLoad )

	AddGlobalAnimEventTokenize( "loot_tick_rarity_random_flash_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_stop_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_flash_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_play_sound", OnLootTickAnimEvent )
}
#endif


#if CLIENT
void function EntitiesDidLoad()
{
	entity targetAnimRef = GetEntByScriptName( "target_loot_ceremony_ref" )
	fileLevel.lootTickMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.lootTickModel = CreatePropDynamic( TICK_MODEL_DEFAULT, fileLevel.lootTickMover.GetOrigin(), fileLevel.lootTickMover.GetAngles() )

	// get end positions of triads when they land on the ground, for lighting rig data
	table< string, table< string, vector > > tickAttachmentOriginsAngles
	Attachment camResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", "CAMERA", 0 )
	foreach ( string attachment in TICK_LOOT_ATTACHMENTS )
	{
		tickAttachmentOriginsAngles[attachment] <- {}

		Attachment attachResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", attachment, 0 )
		vector pos              = attachResult.position
		vector angles           = VectorToAngles( FlattenVector( camResult.position - pos ) )

		tickAttachmentOriginsAngles[ attachment ]["origin"] <- pos
		tickAttachmentOriginsAngles[ attachment ]["angles"] <- angles
	}
	InitLootCeremonyLightingRigs( tickAttachmentOriginsAngles )


	fileLevel.lootTickModel.SetParent( fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )

	fileLevel.cameraMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.cameraEnt = CreateClientSidePointCamera( targetAnimRef.GetOrigin(), targetAnimRef.GetAngles(), CAMERA_FOV )
	fileLevel.cameraEnt.SetParent( fileLevel.cameraMover, "REF" )
	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
}
#endif


#if CLIENT
void function UIToClient_LootCeremony_SetMenuHandles( var menu )
{
	fileLevel.menu = menu
	fileLevel.inspectMenu = Hud_GetChild( menu, "InspectBar" )
	fileLevel.equipButton = Hud_GetChild( menu, "InspectEquipButton" )
	fileLevel.equipToWheelButton = Hud_GetChild( menu, "InspectEquipToWheelButton" )
	fileLevel.mouseClickElem = Hud_GetChild( menu, "ModelRotateMouseCapture" )
	fileLevel.inspectVideoPanel = Hud_GetChild( menu, "InspectVideoPanel" )

	fileLevel.dummyInspectButtons.clear()

	DummyInspectButtonData inspectButton1
	inspectButton1.button = Hud_GetChild( menu, "RewardLeftButton" )
	inspectButton1.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton1 )

	DummyInspectButtonData inspectButton2
	inspectButton2.button = Hud_GetChild( menu, "RewardCenterButton" )
	inspectButton2.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton2 )

	DummyInspectButtonData inspectButton3
	inspectButton3.button = Hud_GetChild( menu, "RewardRightButton" )
	inspectButton3.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton3 )

	fileLevel.skipAnimButton = Hud_GetChild( menu, "SkipAnimationButton" )
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//   ######  ##       #### ######## ##    ## ########     ######   ########  ##     ##
//  ##    ## ##        ##  ##       ###   ##    ##       ##    ##  ##     ##  ##   ##
//  ##       ##        ##  ##       ####  ##    ##       ##        ##     ##   ## ##
//  ##       ##        ##  ######   ## ## ##    ##       ##   #### ########     ###
//  ##       ##        ##  ##       ##  ####    ##       ##    ##  ##   ##     ## ##
//  ##    ## ##        ##  ##       ##   ###    ##       ##    ##  ##    ##   ##   ##
//   ######  ######## #### ######## ##    ##    ##        ######   ##     ## ##     ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if CLIENT
void function UIToClient_OnGRXPackOpeningResultsAvailable()
{
	//Assert( IsLootCeremonyActive() )
	if ( !IsLootCeremonyActive() )
		return

	ItemFlavorBag bag = GRX_GetMostRecentPackOpeningResults()

	// error checking
	int error = GRX_INVENTORYERROR_NONE
	if ( bag.associatedError != -1 )
		error = bag.associatedError
	GRXPackOpened_ErrorHandling( error )

	// populate dev item variables
	#if R5DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			array< ItemFlavor > debugItems
			foreach ( asset itemAsset in fileLevel.debugCustomRewardAssets )
				debugItems.append( GetItemFlavorByAsset( itemAsset ) )

			bag.flavors = debugItems
		}
	#endif

	fileLevel.itemPresentationDatas.clear()

	bool hasCurrency                      = false
	bool hasNonCurrency                   = false
	table<ItemFlavor, int> currencyCounts = {}
	foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
	{
		if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
		{
			hasCurrency = true
			if ( !(bagEntryFlav in currencyCounts) )
				currencyCounts[bagEntryFlav] <- 0
			currencyCounts[bagEntryFlav] += bag.quantities[bagEntryIdx]
		}
		else
		{
			hasNonCurrency = true
		}
	}

	bool hasJustCurrency = hasCurrency && !hasNonCurrency && currencyCounts.len() == 1
	if ( hasJustCurrency ) //
	{
		ItemFlavor currencyFlav
		int currencyQty
		foreach ( ItemFlavor argh, int grr in currencyCounts )
		{ ;currencyFlav = argh;currencyQty = grr;break; }

		int middleQty = int( float( currencyQty ) / 700.0 * 300.0 )
		int leftQty   = int( float( currencyQty - middleQty ) / 2.0 )
		int rightQty  = leftQty
		middleQty += currencyQty - middleQty - leftQty - rightQty

		ItemPresentationData wtfLeft
		wtfLeft.item = currencyFlav
		wtfLeft.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfLeft.attachment = TICK_LOOT_ATTACHMENTS[0]
		wtfLeft.quantity = leftQty
		fileLevel.itemPresentationDatas.append( wtfLeft )

		ItemPresentationData wtfMiddle
		wtfMiddle.item = currencyFlav
		wtfMiddle.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfMiddle.attachment = TICK_LOOT_ATTACHMENTS[1]
		wtfMiddle.quantity = middleQty
		fileLevel.itemPresentationDatas.append( wtfMiddle )

		ItemPresentationData wtfRight
		wtfRight.item = currencyFlav
		wtfRight.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfRight.attachment = TICK_LOOT_ATTACHMENTS[2]
		wtfRight.quantity = rightQty
		fileLevel.itemPresentationDatas.append( wtfRight )
	}
	else if ( GRXPack_IsExpectedToContainSingleItemWithCurrency( fileLevel.currentPackFlav ) )
	{
		ItemFlavor ornull theSingleItemFlav = null
		ItemFlavor ornull theCurrencyFlav   = null
		int theCurrencyQty                  = 0
		foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
		{
			int bagEntryQty = bag.quantities[bagEntryIdx]
			if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
			{
				Assert( theCurrencyFlav == null || theCurrencyFlav == bagEntryFlav )
				theCurrencyFlav = bagEntryFlav
				theCurrencyQty += bagEntryQty
			}
			else
			{
				//
				//
				Assert( ItemFlavor_GetType( bagEntryFlav ) == eItemType.character_skin
						|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.weapon_skin
						|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.gladiator_card_stance
						|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.music_pack )

				//
				Assert( theSingleItemFlav == null )
				theSingleItemFlav = bagEntryFlav
			}
		}

		Assert( theSingleItemFlav != null )
		Assert( theCurrencyFlav != null )
		Assert( theCurrencyQty > 0 )

		if ( !IsEven( theCurrencyQty ) )
			Warning( "Pack %s gave an odd amount of currency but we expected an even amount: %d", ItemFlavor_GetHumanReadableRef( fileLevel.currentPackFlav ), theCurrencyQty )

		int leftCurrencyAmount  = theCurrencyQty / 2
		int rightCurrencyAmount = theCurrencyQty - leftCurrencyAmount

		ItemPresentationData leftCurrencyIPD
		leftCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		leftCurrencyIPD.rarity = ItemFlavor_GetQuality( leftCurrencyIPD.item )
		leftCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[0]
		leftCurrencyIPD.quantity = leftCurrencyAmount
		fileLevel.itemPresentationDatas.append( leftCurrencyIPD )

		ItemPresentationData theSingleItemIPD
		theSingleItemIPD.item = expect ItemFlavor(theSingleItemFlav)
		theSingleItemIPD.rarity = ItemFlavor_GetQuality( theSingleItemIPD.item )
		theSingleItemIPD.attachment = TICK_LOOT_ATTACHMENTS[1]
		fileLevel.itemPresentationDatas.append( theSingleItemIPD )

		ItemPresentationData rightCurrencyIPD
		rightCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		rightCurrencyIPD.rarity = ItemFlavor_GetQuality( rightCurrencyIPD.item )
		rightCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[2]
		rightCurrencyIPD.quantity = rightCurrencyAmount
		fileLevel.itemPresentationDatas.append( rightCurrencyIPD )
	}
	else
	{
		for ( int i = 0; i < bag.quantities.len(); i++ )
			Assert( bag.quantities[i] == 1, "Quantity is not 1 for loot ceremony item flavor: " + ItemFlavor_GetHumanReadableRef( bag.flavors[i] ) )

		array<ItemFlavor> filteredAndSortedItemFlavors = FilterAndSortPackResults( bag.flavors )

		for ( int i = 0; i < filteredAndSortedItemFlavors.len(); i++ )
		{
			ItemFlavor flavor = filteredAndSortedItemFlavors[i]

			ItemPresentationData data
			data.item = flavor
			data.rarity = ItemFlavor_HasQuality( flavor ) ? ItemFlavor_GetQuality( flavor ) : 0
			data.attachment = TICK_LOOT_ATTACHMENTS[i]

			fileLevel.itemPresentationDatas.append( data )
		}
	}

	// allow animation to progress
	fileLevel.grxRewardsReceived = true
}
#endif


#if CLIENT
array<ItemFlavor> function FilterAndSortPackResults( array<ItemFlavor> resultList )
{
	array<ItemFlavor> out = []

	// remove loot ticks/packs since we don't show them for the presentation
	foreach ( ItemFlavor result in resultList )
	{
		if ( ItemFlavor_GetType( result ) == eItemType.account_pack )
			continue

		out.append( result )
	}

	out.randomize()

	// sort melee skins to the beginning of the list, with the list still randomized
	out.sort( int function( ItemFlavor a, ItemFlavor b ) {
		bool aIsMeleeSkin = (ItemFlavor_GetType( a ) == eItemType.melee_skin)
		bool bIsMeleeSkin = (ItemFlavor_GetType( b ) == eItemType.melee_skin)
		if ( aIsMeleeSkin )
			return -1
		if ( bIsMeleeSkin )
			return 1

		return ItemFlavor_GetTags( b ).len() - ItemFlavor_GetTags( a ).len()
	} )

	// put melee skins in the middle slot
	if ( out.len() >= 2 && (ItemFlavor_GetType( out[0] ) == eItemType.melee_skin || ItemFlavor_GetTags( out[0] ).len() > 0) )
	{
		ItemFlavor temp = out[0]
		out[0] = out[1]
		out[1] = temp
	}

	// trim items to the size of tick attachments
	if ( out.len() > TICK_LOOT_ATTACHMENTS.len() )
		out.resize( TICK_LOOT_ATTACHMENTS.len() )

	return out
}
#endif


#if CLIENT
bool function BagIsHeirloom( array<ItemFlavor> flavors )
{
	if ( flavors.len() == 0 )
		return false
	if ( !ItemFlavor_HasQuality( flavors[0] ) )
		return false
	if ( ItemFlavor_GetQuality( flavors[0] ) != eQuality.HEIRLOOM )
		return false

	return true
}
#endif


#if CLIENT
void function GRXPackOpened_ErrorHandling( int packError )
{
	if ( packError == GRX_INVENTORYERROR_NONE )
		return

	string message
	string warningText

	if ( packError == GRX_INVENTORYERROR_UNKNOWNITEM )
	{
		message = "#GRX_ERROR_MESSAGE_UNKNOWNITEM"
		warningText = "Loot Box had an error: UNKNOWNITEM"
	}
	else if ( packError == GRX_INVENTORYERROR_BACKEND )
	{
		message = "#GRX_ERROR_MESSAGE_BACKEND"
		warningText = "Loot Box had an error: BACKEND"
	}
	else
	{
		message = "#GRX_ERROR_MESSAGE_GENERIC"
		warningText = "Loot Box had an error: " + packError
	}

	RunUIScript( "OpenConfirmGrxErrorDialog", message )

	#if R5DEV
		Warning( warningText )
	#endif
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//   ######  ##       #### ######## ##    ## ########    ##     ## ####
//  ##    ## ##        ##  ##       ###   ##    ##       ##     ##  ##
//  ##       ##        ##  ##       ####  ##    ##       ##     ##  ##
//  ##       ##        ##  ######   ## ## ##    ##       ##     ##  ##
//  ##       ##        ##  ##       ##  ####    ##       ##     ##  ##
//  ##    ## ##        ##  ##       ##   ###    ##       ##     ##  ##
//   ######  ######## #### ######## ##    ##    ##        #######  ####
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if CLIENT
void function EnableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		if ( buttonData.shouldShow )
		{
			Hud_SetEnabled( buttonData.button, true )
			Hud_SetVisible( buttonData.button, true )
		}
	}
}
#endif


#if CLIENT
void function DisableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		Hud_SetEnabled( buttonData.button, false )
		Hud_SetVisible( buttonData.button, false )
	}
}
#endif


#if CLIENT
void function UIToClient_SkipAnimation()
{
	//Signal( fileLevel.lootTickModel, "TickAnimSkip" )
}
#endif


#if CLIENT
void function UIToClient_SpecialItemPresentation( SettingsAssetGUID itemFlavorGUID, int itemQty )
{
	thread UIToClient_SpecialItemPresentation_Threaded( itemFlavorGUID, itemQty )
}
#endif

#if CLIENT
void function UIToClient_SpecialItemPresentation_Threaded( SettingsAssetGUID itemFlavorGUID, int itemQty )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = true

	// clear other ui stuff
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	// set up the loot ceremony room
	LootCeremonySceneLightsUpdateShadows( true )

	if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
		fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )

	wait 0.25 // allow for fade in

	// get relevant item and presentation data
	ItemFlavor item     = GetItemFlavorByGUID( itemFlavorGUID )
	int itemType        = ItemFlavor_GetType( item )
	string attachment   = TICK_LOOT_ATTACHMENTS[1]
	int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
	vector attachAngles = VectorToAngles( FlattenVector( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )
	int displayIndex    = TICK_LOOT_ATTACHMENTS.find( attachment )

	int rarity = 0
	if ( ItemFlavor_HasQuality( item ) )
		rarity = ItemFlavor_GetQuality( item )

	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	// set up struct used for inspect menu: RewardInspect_GetCameraOrgAnglesFromMenuButton()
	fileLevel.itemPresentationDatas.clear()
	ItemPresentationData data
	data.item = item
	data.quantity = itemQty
	data.attachment = attachment
	data.rarity = rarity
	fileLevel.itemPresentationDatas.append( data )

	// simulate inspect menu
	InspectMenu_ZoomIn( Hud_GetChild( fileLevel.menu, "RewardCenterButton" ), true )

	// show the reward
	thread ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, itemQty, displayIndex, attachment )

	// sound
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_LOOP )
	RunUIScript( "ClientToUI_UpdateSpecialItemPresentationPurchaseButton" )
	// show the fx
	thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

	EnableInspectMenu()
}
#endif


#if CLIENT
void function UIToClient_SpecialItemPresentationExit()
{
	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = false

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	RunUIScript( "ClientToUI_StopLootCeremonySound", SOUND_HOLOGRAM_LOOP )
	ClearInspectMenuDetails()
	LootCeremonySceneLightsUpdateShadows( false )
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ######## ####  ######  ##    ##       ###    ##    ## #### ##     ##
//     ##     ##  ##    ## ##   ##       ## ##   ###   ##  ##  ###   ###
//     ##     ##  ##       ##  ##       ##   ##  ####  ##  ##  #### ####
//     ##     ##  ##       #####       ##     ## ## ## ##  ##  ## ### ##
//     ##     ##  ##       ##  ##      ######### ##  ####  ##  ##     ##
//     ##     ##  ##    ## ##   ##     ##     ## ##   ###  ##  ##     ##
//     ##    ####  ######  ##    ##    ##     ## ##    ## #### ##     ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if CLIENT
void function UIToClient_EnterLootCeremony( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	fileLevel.menuActive = true
	LootCeremonySceneLightsUpdateShadows( true )

	Chroma_LootCeremonyStart()

	thread TickAnimationSequence( packFlav, true )
}
#endif


#if CLIENT
void function UIToClient_AdditionalLootTick_Sequence( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	Chroma_LootCeremonyStart()

	thread TickAnimationSequence( packFlav, false )
}
#endif


#if CLIENT
void function TickAnimationSequence( ItemFlavor packFlav, bool firstTime )
{
	Signal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// ui stuff
	fileLevel.currentPackFlav = packFlav
	fileLevel.grxRewardsReceived = false
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	// tick setup
	fileLevel.lootTickModel.SetModel( GRXPack_GetTickModel( packFlav ) )
	fileLevel.lootTickModel.SetSkin( fileLevel.lootTickModel.GetSkinIndexByName( GRXPack_GetTickModelSkin( packFlav ) ) )

	string deployAnim = GetTickDeploymentAnim()

	OnThreadEnd(
		function() : ()
		{
			Signal( fileLevel.lootTickModel, "LootCeremonyTickCancelAnim" )

			RunUIScript( "ClientToUI_StopLootCeremonySound", SOUND_HOLOGRAM_LOOP )

			if ( !IsLootCeremonyActive() )
				thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )
			else
				RunUIScript( "PlayCustomUIMusic", "" )
		}
	)

	if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
		fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	if ( firstTime )
		wait 0.25 // allow for fade in

	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P1 )

	// intro animation + idle
	PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal", fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_idle", fileLevel.lootTickMover )

	// wait for sound to ramp up while idling (absolute minimum should be 0.25 seconds for the idle to visually register)
	wait 0.5

	// wait for grx rewards to come in
	while( !fileLevel.grxRewardsReceived )
		WaitFrame()

	// allow skip anim button
	Hud_SetEnabled( fileLevel.skipAnimButton, true )
	Hud_SetVisible( fileLevel.skipAnimButton, true )

	// signal used by fx to end
	Signal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	// sound
	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P2 )
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_DEPLOY_ZOOM )

	// play deployment animation
	thread PlayAnim( fileLevel.lootTickModel, deployAnim, fileLevel.lootTickMover )
	thread WaitForTickAnimCompleteAndSignalDisplayLoot( fileLevel.lootTickModel, deployAnim )

	// wait for either anim to reach its display event or user skips anim (or early exit out of loot ceremony)
	bool animReachedDisplayEvent = false
	array<string> signalsToWait  = ["TickAnimStartDisplayLoot", "TickAnimSkip", "LootCeremonyTickCancelAnim"]
	string resultSignal          = GetWaitMultipleSignal_Entity( fileLevel.lootTickModel, signalsToWait, "LootCeremonyAnimShowLootOrSkip" )

	if ( resultSignal == "TickAnimStartDisplayLoot" )
		animReachedDisplayEvent = true

	// disable the invisible fullscreen skip animation button
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	// display rewards
	if ( animReachedDisplayEvent )
	{
		thread LootCeremonySequenceShowRewards()
		WaittillAnimDone( fileLevel.lootTickModel )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
	}
	else
	{
		LootCeremony_RarityBeamFX_Stop( true )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
		thread LootCeremonySequenceShowRewards()
	}

	WaitForever()
}
#endif


#if CLIENT
string function GetTickDeploymentAnim()
{
	string deployAnim
	int randInt = RandomInt( 100 )

	if ( randInt > 95 )
	{
		// tick rockets away
		deployAnim = "loot_ceremony_tick_deployment"
	}
	else
	{
		array<string> anims = [ "loot_ceremony_tick_deployment_fast_walk", "loot_ceremony_tick_deployment_hop", "loot_ceremony_tick_deployment_jump", "loot_ceremony_tick_deployment_walk"  ]
		deployAnim = anims.getrandom()
	}

	printt( "Loot Ceremony deployment animation: " + deployAnim )
	return deployAnim
}
#endif


#if CLIENT
void function WaitForTickAnimCompleteAndSignalDisplayLoot( entity tickModel, string tickAnim )
{
	// fallback for if players disconnect. loot will display when animation is complete as fallback.
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Wait( tickModel.GetSequenceDuration( tickAnim ) )

	Signal( fileLevel.lootTickModel, "TickAnimStartDisplayLoot" )
}
#endif


#if CLIENT
void function UIToClient_LootCeremonyExit()
{
	fileLevel.menuActive = false

	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	LootCeremonySceneLightsUpdateShadows( false )

	RunUIScript( "CancelCustomUIMusic" )

	// in case we ended the ceremony early
	LootCeremony_RarityBeamFX_Stop( true )

	Chroma_Lobby()
}
#endif


#if CLIENT
void function LootCeremonyOnFullUpdate()
{
	if ( !IsLootCeremonyActive() && !IsSpecialItemPresentationModeActive() )
		return

	printt( "#################" )
	printf( "%s() ", FUNC_NAME() )
	printt( "#################" )

	entity localClientPlayer = GetLocalClientPlayer()
	if ( IsValid( localClientPlayer ) && IsValid( fileLevel.cameraEnt ) )
		localClientPlayer.SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )
}
#endif


#if CLIENT
bool function IsLootCeremonyActive()
{
	return fileLevel.menuActive
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ######## ##     ##
//  ##        ##   ##
//  ##         ## ##
//  ######      ###
//  ##         ## ##
//  ##        ##   ##
//  ##       ##     ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if CLIENT
void function OnLootTickAnimEvent( entity ent, array<string> tokens )
{
	switch ( tokens[0] )
	{
		case "loot_tick_rarity_random_flash_fx":
		{
			thread LootCeremony_RandomFlashFX_Thread( ent )
			break
		}

		case "loot_tick_rarity_beam_start_fx":
		{
			LootCeremony_RarityBeamFX( ent, tokens[1] )
			break
		}

		case "loot_tick_rarity_beam_stop_fx":
		{
			LootCeremony_RarityBeamFX_Stop()
			break
		}

		case "loot_tick_rarity_flash_start_fx":
		{
			LootCeremony_RarityFlashFX( ent, tokens[1], tokens[2] )
			break
		}

		case "loot_tick_play_sound":
		{
			LootCeremony_PlayLootTickSound( ent, tokens[1] )
			break
		}

		default: Assert( false )
	}
}
#endif


#if CLIENT
void function LootCeremony_RandomFlashFX_Thread( entity tickModel )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	if ( fileLevel.tickRandomFlashFXStarted )
		return

	fileLevel.tickRandomFlashFXStarted = true

	OnThreadEnd(
		function() : ()
		{
			fileLevel.tickRandomFlashFXStarted = false
		}
	)

	int attachID = tickModel.LookupAttachment( "FX_C_EYE" )

	while( true )
	{
		int rarity  = 0
		int randInt = RandomInt( 1000 )

		if ( randInt > 995 )
			rarity = 4
		if ( randInt > 970 )
			rarity = 3
		else if ( randInt > 900 )
			rarity = 2
		else if ( randInt > 600 )
			rarity = 1

		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		int fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_IDLE ), FX_PATTACH_POINT_FOLLOW, attachID )
		EffectSetControlPointVector( fxIndex, 1, rarityColor )

		RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_LIGHT_FLASH )

		Wait( RandomFloatRange( 0.2, 0.4 ) )
	}
}
#endif


#if CLIENT
void function LootCeremony_RarityBeamFX( entity tickModel, string fxAttachment )
{
	bool attachmentHasItem = false

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == fxAttachment )
		{
			attachmentHasItem = true
			break
		}
	}

	if ( !attachmentHasItem )
		return

	int rarity         = GetItemRarityFromAttachment( fxAttachment )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	Chroma_LootCeremonyBeam( rarity )

	int attachID = tickModel.LookupAttachment( fxAttachment )
	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break

		case 1:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER2 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER1 )
			break

		case 2:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER3 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER2 )
			break

		case 3:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER4 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER3 )
			break

		case 4:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER5 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER4 )
			break

		default:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )

	fileLevel.rarityBeamFXHandles.append( fxIndex )
}
#endif


#if CLIENT
void function LootCeremony_RarityBeamFX_Stop( bool stopImmediately = false )
{
	foreach ( int fxID in fileLevel.rarityBeamFXHandles )
	{
		if ( EffectDoesExist( fxID ) )
		{
			if ( stopImmediately )
				EffectStop( fxID, true, false )
			else
				EffectStop( fxID, false, true )
		}
	}

	fileLevel.rarityBeamFXHandles.clear()
}
#endif


#if CLIENT
void function LootCeremony_RarityFlashFX( entity tickModel, string attachmentHead, string attachmentEye )
{
	int rarity         = GetItemRarityFromAttachment( attachmentEye )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	int attachID  = tickModel.LookupAttachment( attachmentHead )
	vector origin = tickModel.GetAttachmentOrigin( attachID )
	vector angles = tickModel.GetAttachmentAngles( attachID )

	Chroma_LootCeremonyFlash( rarity )

	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break

		case 1:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER2 ), origin, angles )
			break

		case 2:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER3 ), origin, angles )
			break

		case 3:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER4 ), origin, angles )
			break

		default:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )
}
#endif


#if CLIENT
void function LootCeremony_PlayLootTickSound( entity tickModel, string soundKindRef )
{
	string soundAlias = GRXPack_GetTickSoundAlias( fileLevel.currentPackFlav, eGRXPackTickSoundKind[soundKindRef] )
	if ( soundAlias != "" )
		EmitSoundOnEntity( tickModel, soundAlias )
}
#endif


#if CLIENT
int function GetItemRarityFromAttachment( string compareAttachment )
{
	int rarity = 0

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == compareAttachment )
			return data.rarity
	}

	return rarity
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ########  ######## ##      ##    ###    ########  ########   ######
//  ##     ## ##       ##  ##  ##   ## ##   ##     ## ##     ## ##    ##
//  ##     ## ##       ##  ##  ##  ##   ##  ##     ## ##     ## ##
//  ########  ######   ##  ##  ## ##     ## ########  ##     ##  ######
//  ##   ##   ##       ##  ##  ## ######### ##   ##   ##     ##       ##
//  ##    ##  ##       ##  ##  ## ##     ## ##    ##  ##     ## ##    ##
//  ##     ## ########  ###  ###  ##     ## ##     ## ########   ######
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


const float REWARDS_DELAY_TIER5 = 1.1
const float REWARDS_DELAY_TIER4 = 1.0
const float REWARDS_DELAY_TIER3 = 0.4
const float REWARDS_DELAY_TIER1 = 0.2


#if CLIENT
void function LootCeremonySequenceShowRewards()
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// show 3d rewards
	for ( int i = 0; i < fileLevel.itemPresentationDatas.len(); i++ )
	{
		ItemPresentationData data = fileLevel.itemPresentationDatas[i]
		ItemFlavor item           = data.item
		int quantity              = data.quantity

		// attachment origin and angles
		string attachment   = data.attachment
		int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
		vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
		vector attachAngles = VectorToAngles( FlattenVector( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

		int displayIndex = TICK_LOOT_ATTACHMENTS.find( attachment )

		// item rarity
		int rarity         = data.rarity
		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		// item type
		int itemType = ItemFlavor_GetType( item )

		// play legendary buildup sound
		if ( rarity == 4 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER4 )

			wait REWARDS_DELAY_TIER5
		}
		else if ( rarity == 3 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER3 )

			wait REWARDS_DELAY_TIER4
		}
		else if ( i > 0 )
		{
			if ( rarity == 2 || rarity == 1 )
				wait REWARDS_DELAY_TIER3
			else
				wait REWARDS_DELAY_TIER1
		}


		ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )

		// Placard, FX, sound
		thread ShowRewards_Placard( item, attachOrigin, attachAngles, rarity, displayIndex )
		thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

		if ( i == 0 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_LOOP )
		}

		switch ( rarity )
		{
			case 0:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER0 )
				break

			case 1:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER1 )
				break

			case 2:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER2 )
				break

			case 3:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER3 )
				break

			case 4:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER4 )
				break
		}
	}

	// update the UI
	RunUIScript( "ClientToUI_SetLootHasBeenPresented" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )

	// enable/disable fake inspect buttons
	for ( int i = 0; i < TICK_LOOT_ATTACHMENTS.len(); i++ )
	{
		if ( i < fileLevel.itemPresentationDatas.len() )
			fileLevel.dummyInspectButtons[i].shouldShow = true
		else
			fileLevel.dummyInspectButtons[i].shouldShow = false
	}
	EnableFakeInspectButtons()
}
#endif


#if CLIENT
void function ShowRewardBasedOnItemType( int itemType, ItemFlavor item, vector attachOrigin, vector attachAngles, int rarity, int quantity, int displayIndex, string attachment )
{
	switch ( itemType )
	{
		case eItemType.account_currency:
		case eItemType.account_currency_bundle:
			thread ShowRewards_Currency( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.account_pack:
			if ( item == TEMP_GetVoidwalkerBundle() )
				thread ShowRewards_VoidwalkerBundle( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			else
				thread ShowRewards_LootTick( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.character_skin:
			thread ShowRewards_CharacterSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.character_execution:
			thread ShowRewards_Execution( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.weapon_skin:
			thread ShowRewards_WeaponSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.weapon_charm:
			thread ShowRewards_WeaponCharm( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
			thread ShowRewards_GladiatorCard( item, itemType, attachOrigin, attachAngles, displayIndex, rarity )
			break

		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
			thread ShowRewards_Quip( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_stat_tracker:
			thread ShowRewards_StatTracker( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_badge:
			thread ShowRewards_Badge( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.melee_skin:
			thread ShowRewards_MeleeSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.music_pack:
			thread ShowRewards_MusicPack( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.loadscreen:
			thread ShowRewards_Loadscreen( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		default:
			Warning( "Loot Ceremony reward item type not supported: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
			thread ShowRewards_PLACEHOLDER( item, attachOrigin, attachAngles, rarity, displayIndex )
			break
	}
}
#endif


const float MODEL_ROTATE_SPEED = 15.0
const float CURRENCY_Z_OFFSET = 26.0


#if CLIENT
void function ShowRewards_Currency( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// object representation
	origin += <0, 0, CURRENCY_Z_OFFSET>

	asset modelAsset = $"mdl/dev/empty_model.rmdl"
	float modelScale = 1.0
	bool shouldSpin  = true
	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		//

		if ( GRXCurrency_GetPreviewModel( item ) != $"" )
			modelAsset = GRXCurrency_GetPreviewModel( item )
		modelScale = 0.7
		shouldSpin = GetCurrentPlaylistVarBool( "loot_ceremony_currency_spins", true )
	}
	else
	{
		asset itemAsset = ItemFlavor_GetAsset( item )
		//
		Assert( itemAsset == $"settings/itemflav/currency_bundle/crafting_common.rpak" ||
						itemAsset == $"settings/itemflav/currency_bundle/crafting_rare.rpak" ||
						itemAsset == $"settings/itemflav/currency_bundle/crafting_epic.rpak" ||
						itemAsset == $"settings/itemflav/currency_bundle/crafting_legendary.rpak" )

		switch ( rarity )
		{
			case 0:
				modelAsset = CURRENCY_MODEL_COMMON
				break

			case 1:
				modelAsset = CURRENCY_MODEL_RARE
				break

			case 2:
				modelAsset = CURRENCY_MODEL_EPIC
				break

			case 3:
				modelAsset = CURRENCY_MODEL_LEGENDARY
				break

			default: Assert( false )
		}
	}

	//

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( modelScale )

	if ( shouldSpin )
		moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	//
	ModelIntroHighlightEffect( modelEnt, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}
#endif


#if CLIENT
const float LOOT_TICK_Z_OFFSET = 15.0
void function ShowRewards_LootTick( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	//
	origin += <0, 0, LOOT_TICK_Z_OFFSET>

	asset modelAsset = GRXPack_GetTickModel( item )

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )
	modelEnt.SetSkin( modelEnt.GetSkinIndexByName( GRXPack_GetTickModelSkin( item ) ) )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( 0.5 )

	moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	//
	ModelIntroHighlightEffect( modelEnt, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}
#endif


#if CLIENT
//
void function ShowRewards_VoidwalkerBundle( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	//
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	entity mover             = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	ItemFlavor characterItem = GetItemFlavorByAsset( $"settings/itemflav/character_skin/wraith/season02_event02_legendary_01.rpak" )

	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )
	CharacterSkin_Apply( characterModel, characterItem )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread PlayAnim( characterModel, "ACT_MP_MENU_LOOT_CEREMONY_IDLE", mover )
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )
	ModelIntroHighlightEffect( characterModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	//
	vector forward = origin - fileLevel.cameraMover.GetOrigin()
	forward = Normalize( forward )
	vector bsePos      = origin + <0, 0, 2.5> + (forward * 50)
	vector right       = CrossProduct( forward, <0, 0, 1> )
	vector frameOrigin = bsePos + (right * 25)
	vector poseOrigin  = bsePos - (right * 25)

	ItemFlavor frameItem            = GetItemFlavorByAsset( $"settings/itemflav/gcard_frame/wraith/season02_event02_legendary_01.rpak" )
	GladiatorCardData frameCardData = ShowRewards_GladiatorCard_Create( frameItem, ItemFlavor_GetType( frameItem ), true, ItemFlavor_GetQuality( frameItem ), frameOrigin, angles )

	ItemFlavor poseItem            = GetItemFlavorByAsset( $"settings/itemflav/gcard_stance/wraith/season02_event02_rare_01.rpak" )
	GladiatorCardData poseCardData = ShowRewards_GladiatorCard_Create( poseItem, ItemFlavor_GetType( poseItem ), true, ItemFlavor_GetQuality( poseItem ), poseOrigin, angles )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment, frameCardData, poseCardData )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
			ShowRewards_GladiatorCard_Destroy( frameCardData )
			ShowRewards_GladiatorCard_Destroy( poseCardData )
		}
	)

	Assert( IsSpecialItemPresentationModeActive() )
	//
	//
	PopulateInspectMenuDetails( item, rarity, 1 )
	waitthread TurntableModelController( characterModel, mover, ItemFlavor_GetType( characterItem ) )
}
#endif //


const float CHARACTER_SKIN_Z_OFFSET = 4.0
const float CHARACTER_SKIN_SCALE = 0.7


#if CLIENT
void function ShowRewards_CharacterSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// object representation
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	entity mover          = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )
	CharacterSkin_Apply( characterModel, item )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread PlayAnim( characterModel, "ACT_MP_MENU_LOOT_CEREMONY_IDLE", mover )

	//scale
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )

	// intro effect
	ModelIntroHighlightEffect( characterModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, characterModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, characterModel, mover, angles, 360.0 )
}
#endif


const float EXECUTION_Z_OFFSET = 12.0
const vector EXECUTION_LOCAL_ANGLES = <0, 15, 0>
const float EXECUTION_SCALE = 0.4


#if CLIENT
void function ShowRewards_Execution( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// Get execution data
	ItemFlavor attackerCharacter = CharacterExecution_GetCharacterFlavor( item )
	ItemFlavor characterSkin     = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterSkin( attackerCharacter ) )

	asset attackerAnimSeq = CharacterExecution_GetAttackerPreviewAnimSeq( item )
	asset victimAnimSeq   = CharacterExecution_GetVictimPreviewAnimSeq( item )

	// object setup
	origin += <0, 0, EXECUTION_Z_OFFSET>
	vector startAngles   = AnglesCompose( angles, EXECUTION_LOCAL_ANGLES )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, startAngles )
	entity attackerModel = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )
	entity victimModel   = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )

	CharacterSkin_Apply( attackerModel, characterSkin )
	victimModel.SetModel( $"mdl/humans/class/medium/pilot_medium_generic.rmdl" )

	// animate
	bool attackerHasSequence = attackerModel.Anim_HasSequence( attackerAnimSeq )
	bool victimHasSequence   = victimModel.Anim_HasSequence( victimAnimSeq )

	if ( !attackerHasSequence || !victimHasSequence )
	{
		asset attackerPlayerSettings = CharacterClass_GetSetFile( attackerCharacter )
		string attackerRigWeight     = GetGlobalSettingsString( attackerPlayerSettings, "bodyModelRigWeight" )
		string attackerAnim          = "mp_pt_execution_" + attackerRigWeight + "_attacker_loot"

		attackerModel.Anim_Play( attackerAnim )
		victimModel.Anim_Play( "mp_pt_execution_default_victim_loot" )
		Warning( "Couldn't find menu idles for execution reward: " + DEV_DescItemFlavor( item ) + ". Using fallback anims." )
		if ( !attackerHasSequence )
			Warning( "ATTACKER could not find sequence: " + attackerAnimSeq )
		if ( !victimHasSequence )
			Warning( "VICTIM could not find sequence: " + victimAnimSeq )
	}
	else
	{
		attackerModel.Anim_Play( attackerAnimSeq )
		victimModel.Anim_Play( victimAnimSeq )
	}

	mover.MakeSafeForUIScriptHack()

	attackerModel.MakeSafeForUIScriptHack()
	attackerModel.SetParent( mover )

	victimModel.MakeSafeForUIScriptHack()
	victimModel.SetParent( mover )

	//scale
	attackerModel.SetModelScale( EXECUTION_SCALE )
	victimModel.SetModelScale( EXECUTION_SCALE )

	// intro effect
	ModelIntroHighlightEffect( attackerModel, rarity, true )
	ModelIntroHighlightEffect( victimModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_execution )

	OnThreadEnd(
		function() : ( mover, attackerModel, victimModel, attachment )
		{
			attackerModel.Destroy()
			victimModel.Destroy()
			mover.Destroy()

			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Execution( item, rarity, attackerModel, victimModel, mover )
	else
		InspectMenuFunctionality_Execution( item, displayIndex, rarity, attackerModel, victimModel, mover, startAngles )
}
#endif


const float WEAPON_SKIN_Z_OFFSET = 28.0
const vector WEAPON_SKIN_LOCAL_ANGLES = <10, -90, 0>


#if CLIENT
void function ShowRewards_WeaponSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	// create weapon
	ItemFlavor weaponFlavor = WeaponSkin_GetWeaponFlavor( item )
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel      = CreateClientSidePropDynamic( origin, AnglesCompose( angles, WEAPON_SKIN_LOCAL_ANGLES ), $"mdl/dev/empty_model.rmdl" )
	WeaponCosmetics_Apply( weaponModel, item, null )
	ShowDefaultBodygroupsOnFakeWeapon( weaponModel, WeaponItemFlavor_GetClassname( weaponFlavor ) )
	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WeaponItemFlavor_GetLootCeremonyScale( weaponFlavor ) )
	weaponModel.SetParent( mover )

	// offset
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, WEAPON_SKIN_LOCAL_ANGLES )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( WEAPON_SKIN_LOCAL_ANGLES )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	// intro effect
	ModelIntroHighlightEffect( weaponModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}
#endif


const float WEAPON_CHARM_Z_OFFSET = 32.0
const vector WEAPON_CHARM_LOCAL_ANGLES = <-5, -40, 0>
const float WEAPON_CHARM_BASE_SCALE = 1.0
const float WEAPON_CHARM_EXTRA_SCALE = 1.34


#if(CLIENT)
void function ShowRewards_WeaponCharm( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_CHARM_Z_OFFSET>

	vector moverStartAngles = <0, fileLevel.cameraMover.GetAngles().y + 90, 0>
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, moverStartAngles )
	mover.MakeSafeForUIScriptHack()

	entity weaponModel = CreateClientSidePropDynamic( origin, <0, 0, 0>, $"mdl/dev/empty_model.rmdl" )
	weaponModel.SetModel( $"mdl/weapons/r97/ptpov_r97.rmdl" )
	weaponModel.SetSkin( weaponModel.GetSkinIndexByName( "charm_preview_black" ) )
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WEAPON_CHARM_BASE_SCALE )
	weaponModel.SetParent( mover )
	ShowDefaultBodygroupsOnFakeWeapon( weaponModel, "mp_weapon_r97" )

	weaponModel.SetLocalOrigin( GetAttachmentOriginOffset( weaponModel, "CHARM", WEAPON_CHARM_LOCAL_ANGLES ) )
	weaponModel.SetLocalAngles( WEAPON_CHARM_LOCAL_ANGLES )

	WeaponCosmetics_Apply( weaponModel, null, item )

	entity charmEnt = GetCharmForWeaponEntity( weaponModel )
	charmEnt.SetModelScale( WEAPON_CHARM_BASE_SCALE * WEAPON_CHARM_EXTRA_SCALE )

	ModelIntroHighlightEffect( weaponModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, charmEnt, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			if ( IsValid( charmEnt ) )
				charmEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 50.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, moverStartAngles, 50.0 )
}
#endif


const vector MELEE_SKIN_LOCAL_ANGLES = <100, -90, 0>
const float MELEE_SKIN_SCALE = 1.8


#if CLIENT
void function ShowRewards_MeleeSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	vector extraRotation = MeleeSkin_GetMenuModelRotation( item )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel   = CreateClientSidePropDynamic( origin, AnglesCompose( angles, extraRotation ), $"mdl/dev/empty_model.rmdl" )

	asset modelAsset = MeleeSkin_GetMenuModel( item )
	weaponModel.SetModel( modelAsset )

	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )

	asset animSeq = MeleeSkin_GetMenuAnimSeq( item )
	if ( animSeq != $"" )
		weaponModel.Anim_Play( animSeq )

	weaponModel.SetModelScale( MELEE_SKIN_SCALE )
	weaponModel.SetParent( mover )

	// offset
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, extraRotation )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( extraRotation )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	// intro effect
	ModelIntroHighlightEffect( weaponModel, rarity, true )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}
#endif


#if CLIENT
void function ModelIntroHighlightEffect( entity model, int rarity, bool firstTime )
{
	float intensityScalar
	float fadeInTime
	float fadeOutTime
	float lifeTime

	vector color = GetFXRarityColorForUnlockable( rarity )
	color = <color.x / 255, color.y / 255, color.z / 255>

	if ( firstTime )
	{
		intensityScalar = 5000.0
		fadeInTime = 0.2
		fadeOutTime = 0.75
		lifeTime = 1.0

		if ( rarity > 2 )
		{
			fadeInTime = 0.75
			fadeOutTime = 1.0
			lifeTime = 2.0
		}
	}
	else
	{
		intensityScalar = 25.0
		fadeInTime = 0.1
		fadeOutTime = 0.25
		lifeTime = 0.35
	}

	if ( IsValid( model ) )
	{
		thread MenuModelHighlightBloomOnEntityAndChildren( model, color, intensityScalar, fadeInTime, fadeOutTime, lifeTime )
	}
}
#endif


#if CLIENT
void function MenuModelHighlightBloomOnEntityAndChildren( entity ent, vector color, float intensityScalar, float fadeInTime, float fadeOutTime, float lifeTime )
{
	WaitFrame()

	if ( !IsValid( ent ) )
		return

	foreach ( entity hierachyEnt in GetEntityAndImmediateChildren( ent ) )
		MenuModelHighlightBloom( hierachyEnt, color, intensityScalar, fadeInTime, fadeOutTime, lifeTime )
}
#endif


const float GLADIATOR_CARD_WIDTH = 528.0
const float GLADIATOR_CARD_HEIGHT = 912.0
const float GLADIATOR_CARD_Z_OFFSET = 2.0


#if CLIENT
void function ShowRewards_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	GladiatorCardData gCardData = ShowRewards_GladiatorCard_Create( item, itemType, true, rarity, origin, angles )

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_GladiatorCard( item, itemType, rarity, gCardData )
	else
		InspectMenuFunctionality_GladiatorCard( item, itemType, origin, angles, displayIndex, rarity, gCardData )
}
#endif


#if CLIENT
GladiatorCardData function ShowRewards_GladiatorCard_Create( ItemFlavor item, int itemType, bool firstTime, int rarity, vector origin, vector angles )
{
	entity player    = GetLocalClientPlayer()
	vector ruiOrigin = origin + <0, 0, GLADIATOR_CARD_Z_OFFSET>
	vector ruiAngles = AnglesCompose( angles, <0, 180, 0> )
	float width      = GLADIATOR_CARD_WIDTH / 16.0
	float height     = GLADIATOR_CARD_HEIGHT / 16.0
	var topo         = CreateRUITopology_Worldspace( ruiOrigin + <0, 0, height * 0.5>, ruiAngles, width, height )
	var parentRui    = RuiCreate( $"ui/loot_ceremony_glad_card.rpak", topo, RUI_DRAW_WORLD, 0 )

	int gcardPresentation
	if ( itemType == eItemType.gladiator_card_frame )
		gcardPresentation = eGladCardPresentation.FRONT_FRAME_ONLY
	else
		gcardPresentation = eGladCardPresentation.FRONT_STANCE_ONLY

	NestedGladiatorCardHandle nestedGCHandleFront = CreateNestedGladiatorCard( parentRui, "card", eGladCardDisplaySituation.MENU_LOOT_CEREMONY_ANIMATED, gcardPresentation )
	ChangeNestedGladiatorCardOwner( nestedGCHandleFront, ToEHI( player ) )

	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor character = GladiatorCardFrame_GetCharacterFlavor( item )
		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, item )
	}
	else
	{
		ItemFlavor character = GladiatorCardStance_GetCharacterFlavor( item )
		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideStance( nestedGCHandleFront, item )

		ItemFlavor characterDefaultFrame = GetDefaultItemFlavorForLoadoutSlot( EHI_null, Loadout_GladiatorCardFrame( character ) )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, characterDefaultFrame ) // (dw): for the lighting
	}

	GladiatorCardData gCardData
	gCardData.handle = nestedGCHandleFront
	gCardData.rui = parentRui
	gCardData.topo = topo

	RuiSetBool( parentRui, "firstTime", firstTime )
	RuiSetInt( parentRui, "rarity", rarity )

	return gCardData
}
#endif


#if CLIENT
void function ShowRewards_GladiatorCard_Destroy( GladiatorCardData gCardData )
{
	CleanupNestedGladiatorCard( gCardData.handle )
	RuiDestroyIfAlive( gCardData.rui )

	if ( gCardData.topo != null )
	{
		RuiTopology_Destroy( gCardData.topo )
		gCardData.topo = null
	}
}
#endif


const float RUI_QUIP_WIDTH = 390.0
const float RUI_QUIP_HEIGHT = 208.0
const float RUI_QUIP_Z_OFFSET = 24.0


#if CLIENT
void function ShowRewards_Quip( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// Create the RUI and BG/backplate model
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topoQuip = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	// Populate the RUI settings
	var ruiQuip
	ItemFlavor quipCharacter
	string labelText

	if ( ItemFlavor_GetType( item ) == eItemType.gladiator_card_intro_quip )
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterIntroQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_INTRO"
	}
	else
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_kill_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterKillQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_Kill"
	}

	RuiSetBool( ruiQuip, "isVisible", true )
	RuiSetInt( ruiQuip, "rarity", rarity )
	RuiSetImage( ruiQuip, "portraitImage", CharacterClass_GetGalleryPortrait( quipCharacter ) )
	RuiSetString( ruiQuip, "quipTypeText", labelText )
	RuiTrackFloat( ruiQuip, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( ruiQuip, topoQuip, bgModel )
		{
			RuiDestroyIfAlive( ruiQuip )
			RuiTopology_Destroy( topoQuip )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Quip( item, rarity, ruiQuip )
	else
		InspectMenuFunctionality_Quip( item, displayIndex, rarity, ruiQuip, bgModel )
}
#endif


#if CLIENT
void function ShowRewards_MusicPack( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	//
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topo = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	//
	var rui = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topo, RUI_DRAW_WORLD, 0 )

	RuiSetBool( rui, "isVisible", true )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetImage( rui, "portraitImage", MusicPack_GetPortraitImage( item ) )
	RuiSetFloat( rui, "portraitBlend", MusicPack_GetPortraitBlend( item ) )
	RuiSetString( rui, "quipTypeText", "#MUSIC_PACK" )
	RuiTrackFloat( rui, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( rui, topo, bgModel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_MusicPack( item, rarity, rui )
	else
		InspectMenuFunctionality_MusicPack( item, displayIndex, rarity, rui, bgModel )
}
#endif


const float STAT_TRACKER_WIDTH = 594.0
const float STAT_TRACKER_HEIGHT = 230.0
const float STAT_TRACKER_Z_OFFSET = 27.0
const float STAT_TRACKER_SCALE_DIVIDE_BY = 24.0


#if CLIENT
void function ShowRewards_StatTracker( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// Create the RUI and BG/backplate model
	vector placardOrigin = origin + <0, 0, STAT_TRACKER_Z_OFFSET>
	float width          = STAT_TRACKER_WIDTH / STAT_TRACKER_SCALE_DIVIDE_BY
	float height         = STAT_TRACKER_HEIGHT / STAT_TRACKER_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoStatTracker = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiStatTracker  = RuiCreate( $"ui/loot_ceremony_stat_tracker.rpak", topoStatTracker, RUI_DRAW_WORLD, 0 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, STAT_TRACKER_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / STAT_TRACKER_SCALE_DIVIDE_BY )

	ItemFlavor character = GladiatorCardStatTracker_GetCharacterFlavor( item )

	RuiSetBool( ruiStatTracker, "isVisible", true )
	UpdateRuiWithStatTrackerData( ruiStatTracker, "tracker", LocalClientEHI(), character, -1, item, null, true )
	RuiSetColorAlpha( ruiStatTracker, "trackerColor0", GladiatorCardStatTracker_GetColor0( item ), 1.0 )

	OnThreadEnd(
		function() : ( ruiStatTracker, topoStatTracker, bgModel )
		{
			RuiDestroyIfAlive( ruiStatTracker )
			RuiTopology_Destroy( topoStatTracker )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiStatTracker, "#STAT_TRACKER_DESCRIPTION" )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiStatTracker, bgModel, "#STAT_TRACKER_DESCRIPTION" )
}
#endif



const float BADGE_Z_OFFSET = 20.0


#if CLIENT
void function ShowRewards_Badge( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )


	const float BATTLEPASS_BADGE_WIDTH = 500.0
	const float BATTLEPASS_BADGE_HEIGHT = 500.0
	const float BATTLEPASS_BADGE_SCALE = 0.06

	//
	vector placardOrigin = origin + <0, 0, BADGE_Z_OFFSET>
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	float width  = BATTLEPASS_BADGE_WIDTH * BATTLEPASS_BADGE_SCALE
	float height = BATTLEPASS_BADGE_HEIGHT * BATTLEPASS_BADGE_SCALE

	var topoBadge = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiBadge  = RuiCreate( $"ui/world_space_badge.rpak", topoBadge, RUI_DRAW_VIEW_MODEL, 0 )
	RuiSetFloat( ruiBadge, "bloomScale", 0.2 )

	entity bgModel = null//
	//
	//

	ItemFlavor character = GladiatorCardBadge_GetCharacterFlavor( item )

	RuiSetBool( ruiBadge, "isVisible", true )

	int ornull overrideDataIntegerOrNull      = null
	bool TEMP_showOneTierHigherThanIsUnlocked = true

	//
	if ( item == GetItemFlavorByAsset( $"settings/itemflav/gcard_badge/account/season02_bplevel.rpak" ) )
	{
		overrideDataIntegerOrNull = 110
		TEMP_showOneTierHigherThanIsUnlocked = false
	}
	CreateNestedGladiatorCardBadge( ruiBadge, "badge", LocalClientEHI(), item, -1, null, overrideDataIntegerOrNull, TEMP_showOneTierHigherThanIsUnlocked )

	OnThreadEnd(
		function() : ( ruiBadge, topoBadge, bgModel )
		{
			RuiDestroyIfAlive( ruiBadge )
			RuiTopology_Destroy( topoBadge )
			if ( IsValid( bgModel ) )
				bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiBadge, ItemFlavor_GetShortDescription( item ) )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiBadge, bgModel, ItemFlavor_GetShortDescription( item ) )
}
#endif


#if CLIENT
const float RUI_LOADSCREEN_WIDTH = 800.0
const float RUI_LOADSCREEN_HEIGHT = 450.0
const float RUI_LOADSCREEN_Z_OFFSET = 30

void function ShowRewards_Loadscreen( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	//
	vector placardOrigin = origin + <0, 0, RUI_LOADSCREEN_Z_OFFSET>
	float width          = RUI_LOADSCREEN_WIDTH / 16.0
	float height         = RUI_LOADSCREEN_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	//
	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/world_space_loadscreen.rpak", topo, RUI_DRAW_WORLD, 0 )

	if ( IsSpecialItemPresentationModeActive() )
		PopulateInspectMenuDetails( item, rarity, 1, "", "" ) //
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )

	RuiSetImage( rui, "loadscreenImage", $"" )

	OnThreadEnd(
		function() : ( rui, topo )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )

			//
			foreach( handle in fileLevel.pakHandles )
			{
				if ( handle.isAvailable )
					ReleasePakFile( handle )
			}
		}
	)

	WaitFrame() //

	//
	string rpak         = Loadscreen_GetRPakName( item )
	PakHandle pakHandle = RequestPakFile( rpak )
	fileLevel.pakHandles.append( pakHandle )

	if ( !pakHandle.isAvailable )
		WaitSignal( pakHandle, "PakFileLoaded" )

	RuiSetImage( rui, "loadscreenImage", Loadscreen_GetLoadscreenImageAsset( item ) )

	WaitForever()
}
#endif


const float RUI_PLACEHOLDER_WIDTH = 450.0
const float RUI_PLACEHOLDER_HEIGHT = 200.0
const float RUI_PLACEHOLDER_Z_OFFSET = 25


#if CLIENT
void function ShowRewards_PLACEHOLDER( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// pin from the center
	vector placardOrigin = origin + <0, 0, RUI_PLACEHOLDER_Z_OFFSET>
	float width          = RUI_PLACEHOLDER_WIDTH / 16.0
	float height         = RUI_PLACEHOLDER_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlaceholder = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var ruiPlaceholder  = RuiCreate( $"ui/loot_reward_temp.rpak", topoPlaceholder, RUI_DRAW_WORLD, 0 )

	RuiSetString( ruiPlaceholder, "bodyText", Localize( ItemFlavor_GetLongName( item ) ) )

	OnThreadEnd(
		function() : ( ruiPlaceholder, topoPlaceholder )
		{
			RuiDestroyIfAlive( ruiPlaceholder )
			RuiTopology_Destroy( topoPlaceholder )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiPlaceholder )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiPlaceholder )
}
#endif


const float RUI_PLACARD_WIDTH = 550.0
const float RUI_PLACARD_HEIGHT = 256.0
const float RUI_PLACARD_Z_OFFSET = 7.0
const float RUI_PLACARD_FORWARD_OFFSET = 32.0
const bool RUI_PLACARD_DEBUG = false


#if CLIENT
void function ShowRewards_Placard( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	// pin from the bottom
	vector placardOrigin = origin + (AnglesToForward( angles ) * RUI_PLACARD_FORWARD_OFFSET) + <0, 0, RUI_PLACARD_Z_OFFSET>
	float width          = RUI_PLACARD_WIDTH / 18.0
	float height         = RUI_PLACARD_HEIGHT / 18.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlacard = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiPlacard  = RuiCreate( $"ui/loot_placard.rpak", topoPlacard, RUI_DRAW_WORLD, 1 )

	RuiSetInt( ruiPlacard, "rarity", rarity )
	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( item ) )
	}
	else if ( ItemFlavor_GetType( item ) == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( currencyFlav ) )
	}
	else
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetTypeName( item ) )
	}

	fileLevel.rewardPlacards[ INSPECT_BUTTONS[displayIndex] ] = ruiPlacard

	OnThreadEnd(
		function() : ( ruiPlacard, topoPlacard, displayIndex )
		{
			RuiDestroyIfAlive( ruiPlacard )
			RuiTopology_Destroy( topoPlacard )

			fileLevel.rewardPlacards[INSPECT_BUTTONS[displayIndex]] = null
		}
	)

	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		RuiSetBool( ruiPlacard, "visible", false )

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( ruiPlacard, "visible", true )
	}
}
#endif


#if CLIENT
void function UIToClient_RewardPlacard_Hover( var menuButton, bool isHovered )
{
	var rui = RewardPlacard_GetRuiFromMenuButton( menuButton )

	if ( IsValid( rui ) )
		RuiSetBool( rui, "isHovered", isHovered )
}
#endif


#if CLIENT
var function RewardPlacard_GetRuiFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )

	return fileLevel.rewardPlacards[menuButtonName]
}
#endif


#if CLIENT
void function ShowInspect_FX( int animAttachID, int rarity, vector rarityColor )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	//
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		default:
			Assert( 0, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	WaitForever()
}

void function ShowRewards_FX( int animAttachID, int rarity, vector rarityColor, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Chroma_LootCeremonyReward( displayIndex, rarity )

	//fx
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		default:
			Assert( 0, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	if ( IsSpecialItemPresentationModeActive() )
	{
		OnThreadEnd(
			function() : ( fxIndexRarity, fxTrackerBeam )
			{
				if ( EffectDoesExist( fxIndexRarity ) )
					EffectStop( fxIndexRarity, true, false )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		)

		WaitForever()
	}
	else
		InspectMenuFunctionality_FXBeams( displayIndex, fxIndexRarity, fxTrackerBeam, animAttachID, rarityColor )
}
#endif


#if CLIENT && R5DEV
void function DEV_ShouldShowCustomLootRewards( bool shouldShow )
{
	fileLevel.debugShowCustomRewards = shouldShow
}
#endif

#if CLIENT && R5DEV
void function DEV_SetCustomLootRewardsToDisplay( string itemRef0 = "", string itemRef1 = "", string itemRef2 = "" )
{
	DEV_ShouldShowCustomLootRewards( true )

	array<string> flavorRefs = [itemRef0, itemRef1, itemRef2]
	array<asset> flavorAssets

	foreach ( string ref in  flavorRefs )
	{
		if ( ref == "" )
			continue

		ItemFlavor flavor = GetItemFlavorByHumanReadableRef( ref )
		asset flavorAsset = ItemFlavor_GetAsset( flavor )
		flavorAssets.append( flavorAsset )
	}

	fileLevel.debugCustomRewardAssets = flavorAssets
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  #### ##    ##  ######  ########  ########  ######  ########
//   ##  ###   ## ##    ## ##     ## ##       ##    ##    ##
//   ##  ####  ## ##       ##     ## ##       ##          ##
//   ##  ## ## ##  ######  ########  ######   ##          ##
//   ##  ##  ####       ## ##        ##       ##          ##
//   ##  ##   ### ##    ## ##        ##       ##    ##    ##
//  #### ##    ##  ######  ##        ########  ######     ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


const float INSPECT_ZOOM_TIME = 0.25


#if CLIENT
void function UIToClient_RewardInspectActivate( var menuButton )
{
	thread UIToClient_RewardInspectActivate_Threaded( menuButton )
}
#endif


#if CLIENT
void function UIToClient_RewardInspectActivate_Threaded( var menuButton )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	table<string, bool> success = { result = false }

	// UI buttons to Hide
	RunUIScript( "ClientToUI_SetInspectModeIsActive" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	DisableFakeInspectButtons()

	// hide rewards
	string menuButtonName = Hud_GetHudName( menuButton )
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStart", { inspectButton = menuButtonName } )

	// zoom in
	InspectMenu_ZoomIn( menuButton )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_IN )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

					DisableInspectMenu()
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	EnableInspectMenu()
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStartComplete" )

	success[ "result" ] = true
}
#endif


#if CLIENT
void function InspectMenu_ZoomIn( var menuButton, bool instantZoom = false )
{
	table<string, vector> zoomOrgAngles = RewardInspect_GetCameraOrgAnglesFromMenuButton( menuButton )

	InspectMenu_SetZoom( zoomOrgAngles[ "origin" ], zoomOrgAngles[ "angles" ], instantZoom )
}

void function InspectMenu_SetZoom( vector zoomOrigin, vector zoomAngles, bool instantZoom = false )
{
	fileLevel.cameraMover.ClearParent()

	if ( instantZoom )
	{
		fileLevel.cameraMover.SetOrigin( zoomOrigin )
		fileLevel.cameraMover.SetAngles( zoomAngles )
	}
	else
	{
		fileLevel.cameraMover.NonPhysicsMoveTo( zoomOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
		fileLevel.cameraMover.NonPhysicsRotateTo( zoomAngles, INSPECT_ZOOM_TIME, 0, 0.1 )
	}
}
#endif


#if CLIENT
void function UIToClient_RewardInspectNavBack()
{
	thread UIToClient_RewardInspectNavBack_Threaded()
}
#endif


#if CLIENT
void function UIToClient_RewardEquipOnClick()
{
	#if R5DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			Warning( "Trying to equip a reward you may not actually own. You should disable custom rewards." )
		}
	#endif

	if ( Hud_IsLocked( fileLevel.equipButton ) )
	{
		RunUIScript( "ClientToUI_PlayLootCeremonySound", "menu_deny" )
		return
	}

	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )

	int itemType              = ItemFlavor_GetType( fileLevel.equipButtonItemFlavor )
	array<LoadoutEntry> entry = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	if ( entry.len() == 1 )
	{
		UIToClient_RewardEquipOnClickWithIndex( 0 )
	}
	else
	{
		RunUIScript( "ClientToUI_EquipButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	}
}

void function UIToClient_RewardEquipOnClickWithIndex( int index )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, index )

	Hud_SetLocked( fileLevel.equipButton, true )
	var rui = Hud_GetRui( fileLevel.equipButton )
	RuiSetString( rui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
	RuiSetString( rui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( fileLevel.equipButtonItemFlavor ) ) ) )

	int rarity = 0
	if ( ItemFlavor_HasQuality( fileLevel.equipButtonItemFlavor ) )
		rarity = ItemFlavor_GetQuality( fileLevel.equipButtonItemFlavor )

	RuiSetInt( rui, "descTextRarity", rarity )
}

void function UIToClient_RewardEquipToWheelOnClick()
{
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	RunUIScript( "ClientToUI_EquipToWheelButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
}

void function UIToClient_RewardEquipToWheelOnClickWithIndex( int index )
{
	array<LoadoutEntry> entries = []
	ItemFlavor character        = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( fileLevel.equipButtonItemFlavor ) )

	for ( int i = 0; i < MAX_QUIPS_EQUIPPED; i++ )
	{
		LoadoutEntry entry = Loadout_CharacterQuip( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
		{
			entries.append( entry )
		}
	}

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, index )
}
#endif


#if CLIENT || UI 
array<LoadoutEntry> function EquipButton_GetItemLoadoutEntries( ItemFlavor item, bool statTrackerFindExistingEntry = false )
{
	int itemType = ItemFlavor_GetType( item )
	array<LoadoutEntry> entry

	switch ( itemType )
	{
		case eItemType.character_skin:
			entry = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.weapon_skin:
			entry = [ Loadout_WeaponSkin( WeaponSkin_GetWeaponFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_frame:
			entry = [ Loadout_GladiatorCardFrame( GladiatorCardFrame_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_stance:
			entry = [ Loadout_GladiatorCardStance( GladiatorCardStance_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.character_execution:
			entry = [ Loadout_CharacterExecution( CharacterExecution_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_intro_quip:
			entry = [ Loadout_CharacterIntroQuip( CharacterIntroQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_kill_quip:
			entry = [ Loadout_CharacterKillQuip( CharacterKillQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_stat_tracker:
			if ( statTrackerFindExistingEntry )
			{
				entry = [ PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( item, statTrackerFindExistingEntry ) ]
			}
			else
			{
				ItemFlavor character = GladiatorCardStatTracker_GetCharacterFlavor( item )
				for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
				{
					LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
						entry.append( trackerSlot )
				}
			}
			break

		case eItemType.melee_skin:
			entry = [ Loadout_MeleeSkin( MeleeSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_badge:
			ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterClass() )

			for ( int badgeIndex = 0; badgeIndex < GLADIATOR_CARDS_NUM_BADGES; badgeIndex++ )
			{
				LoadoutEntry badgeSlot = Loadout_GladiatorCardStatTracker( character, badgeIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), badgeSlot ) )
					entry.append( badgeSlot )
			}
			break

		case eItemType.music_pack:
			entry = [ Loadout_MusicPack() ]
			break

		case eItemType.loadscreen:
			entry = [ Loadout_Loadscreen() ]
			break

		default:
			Assert( 0, "Loot Ceremony equip button does not support reward type: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
	}

	return entry
}
#endif


#if CLIENT || UI 
LoadoutEntry function PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( ItemFlavor item, bool findExistingEntry )
{
	ItemFlavor character = GladiatorCardStatTracker_GetCharacterFlavor( item )

	for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
	{
		LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
		ItemFlavor flavor        = LoadoutSlot_GetItemFlavor( LocalClientEHI(), trackerSlot )

		if ( findExistingEntry )
		{
			if ( flavor == item )
				return trackerSlot
		}
		else if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
		{
			if ( GladiatorCardTracker_IsTheEmpty( flavor ) )
				return trackerSlot
		}
	}

	LoadoutEntry fallback = Loadout_GladiatorCardStatTracker( character, (GLADIATOR_CARDS_NUM_TRACKERS - 1) )
	return fallback
}
#endif


#if CLIENT
void function UIToClient_RewardInspectNavBack_Threaded()
{
	if ( fileLevel.inspectMenuIsNavigatingBack )
		return

	fileLevel.inspectMenuIsNavigatingBack = true

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	table<string, bool> success = { result = false }

	DisableInspectMenu()

	// move to new position
	int attachID        = fileLevel.lootTickModel.LookupAttachment( "CAMERA" )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = fileLevel.lootTickModel.GetAttachmentAngles( attachID )

	fileLevel.cameraMover.NonPhysicsMoveTo( attachOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
	fileLevel.cameraMover.NonPhysicsRotateTo( attachAngles, INSPECT_ZOOM_TIME, 0, 0.1 )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_OUT )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
					fileLevel.inspectMenuIsNavigatingBack = false
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	RunUIScript( "ClientToUI_ClearInspectModeIsActive" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	EnableFakeInspectButtons()
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_RESETVIEW )

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

	fileLevel.inspectMenuIsNavigatingBack = false
	success[ "result" ] = true
}
#endif


#if CLIENT
void function EnableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, true )
	Hud_SetVisible( fileLevel.inspectMenu, true )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", true )

	// equip button is sometimes disabled, and handled in the populate function
	// inspect video panel is handled in the inspect thread

	Hud_SetEnabled( fileLevel.mouseClickElem, true )
	Hud_SetVisible( fileLevel.mouseClickElem, true )
}
#endif


#if CLIENT
void function DisableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, false )
	Hud_SetVisible( fileLevel.inspectMenu, false )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", false )

	Hud_SetEnabled( fileLevel.equipButton, false )
	Hud_SetVisible( fileLevel.equipButton, false )

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	Hud_SetEnabled( fileLevel.mouseClickElem, false )
	Hud_SetVisible( fileLevel.mouseClickElem, false )

	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )
	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
}
#endif


const float INSPECT_FORWARD_OFFSET = 136.0
const float INSPECT_FORWARD_OFFSET_WEAPON = 100.0
const float INSPECT_FORWARD_OFFSET_CHARM = 45.0
const float INSPECT_FORWARD_OFFSET_EXECUTION = 100.0
const float INSPECT_FORWARD_OFFSET_CURRENCY = 100.0

const float INSPECT_RIGHT_OFFSET = -24.0
const float INSPECT_RIGHT_OFFSET_WEAPON = -18.0
const float INSPECT_RIGHT_OFFSET_CHARM = -7.5
const float INSPECT_RIGHT_OFFSET_EXECUTION = -20.0
const float INSPECT_RIGHT_OFFSET_CURRENCY = -20.0

const float INSPECT_UP_OFFSET = 30.0
const float INSPECT_UP_OFFSET_EXECUTION = 28.0
const float INSPECT_UP_OFFSET_CHARM = 30.0


#if CLIENT
table<string, vector> function RewardInspect_GetCameraOrgAnglesFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )
	int menuButtonIndex   = INSPECT_BUTTONS.find( menuButtonName )
	string attachment     = TICK_LOOT_ATTACHMENTS[menuButtonIndex]

	int itemType
	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == attachment )
		{
			itemType = ItemFlavor_GetType( data.item )
			break
		}
	}

	return RewardInspect_GetCameraOrgAngles( attachment, itemType )
}

table<string, vector> function RewardInspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_WEAPON
		rightOffset = INSPECT_RIGHT_OFFSET_WEAPON
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CHARM
		rightOffset = INSPECT_RIGHT_OFFSET_CHARM
		upOffset = INSPECT_UP_OFFSET_CHARM
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_EXECUTION
		rightOffset = INSPECT_RIGHT_OFFSET_EXECUTION
		upOffset = INSPECT_UP_OFFSET_EXECUTION
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = INSPECT_RIGHT_OFFSET_CURRENCY
		upOffset = INSPECT_UP_OFFSET
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = INSPECT_RIGHT_OFFSET
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVector( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVector( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}

table<string, vector> function Inspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 26
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 18
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.character_skin )
	{
		forwardOffset = 212
		rightOffset = 0
		upOffset = 20
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVector( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVector( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}
#endif


#if CLIENT
bool function ShouldShowControlHintsForItemType( int itemType )
{
	switch( itemType )
	{
		case eItemType.account_currency_bundle:
		case eItemType.character_skin:
		case eItemType.weapon_skin:
		case eItemType.melee_skin:
		case eItemType.character_execution:
			return true
	}

	return false
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_WeaponSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( WeaponSkin_GetWeaponFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_MeleeSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( MeleeSkin_GetCharacterFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_CharacterSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( CharacterSkin_GetCharacterFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails( ItemFlavor item, int rarity, int quantity, string miscString = "", string descString = "" )
{
	int itemType = ItemFlavor_GetType( item )

	var rui             = Hud_GetRui( fileLevel.inspectMenu )
	string itemTypeName = ItemFlavor_GetTypeName( item )
	string itemName     = "?"
	if ( itemType == eItemType.gladiator_card_stat_tracker )
	{
		itemName = Localize( ItemFlavor_GetShortName( item ) )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		itemTypeName = ItemFlavor_GetShortName( currencyFlav )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( currencyFlav ) ), GRXCurrencyBundle_GetValue( item ) )
	}
	else if ( itemType == eItemType.account_currency )
	{
		itemTypeName = ItemFlavor_GetShortName( item )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( item ) ), quantity )
	}
	else if ( itemType == eItemType.account_pack )
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
		if ( quantity != 1 )
			itemName += " x" + quantity
	}
	else
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
	}

	if ( itemType == eItemType.gladiator_card_badge )
	{
		descString = ""
	}

	if ( item == TEMP_GetVoidwalkerBundle() ) //
	{
		miscString = "#SEASON02_EVENT02_TITLE_SHORT"
		itemTypeName = "#BUNDLE"
		itemName = ""

		RuiSetString( rui, "bundleItemText1", "Ghostwraith Skin" )
		RuiSetInt( rui, "bundleItemRarity1", 3 )
		RuiSetString( rui, "bundleItemText2", "Void Shadow Banner Frame" )
		RuiSetInt( rui, "bundleItemRarity2", 3 )
		RuiSetString( rui, "bundleItemText3", "Guarded Banner Pose" )
		RuiSetInt( rui, "bundleItemRarity3", 1 )
	}
	else
	{
		RuiSetString( rui, "bundleItemText1", "" )
		RuiSetString( rui, "bundleItemText2", "" )
		RuiSetString( rui, "bundleItemText3", "" )
	}

	RuiSetString( rui, "itemType", itemTypeName )
	RuiSetString( rui, "itemName", itemName )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetString( rui, "miscText", miscString )
	RuiSetString( rui, "descText", descString )
	RuiSetBool( rui, "showControlsHints", ShouldShowControlHintsForItemType( itemType ) )

	// raise the description text if we're a stat tracker
	RuiSetFloat( rui, "descTextPositionScalar", ((itemType == eItemType.gladiator_card_stat_tracker) ? 1.0 : 0.0) )


	// clear mark as new since we're inspecting it
	if ( itemType != eItemType.account_currency_bundle )
		RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( item ) )

	// equip button
	fileLevel.equipButtonItemFlavor = item
	var equipButtonRui = Hud_GetRui( fileLevel.equipButton )

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	if ( itemType == eItemType.weapon_charm || itemType == eItemType.account_currency_bundle || itemType == eItemType.account_currency || itemType == eItemType.account_pack )
	{
		Hud_SetVisible( fileLevel.equipButton, false )
		Hud_SetEnabled( fileLevel.equipButton, false )
	}
	else if ( IsItemEquipped( item ) )
	{
		Hud_SetVisible( fileLevel.equipButton, true )

		if ( ItemFlavor_CanEquipToWheel( item ) )
		{
			Hud_SetVisible( fileLevel.equipToWheelButton, true )
			Hud_SetEnabled( fileLevel.equipToWheelButton, true )
		}

		Hud_SetEnabled( fileLevel.equipButton, true )
		Hud_SetLocked( fileLevel.equipButton, true )

		RuiSetString( equipButtonRui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", rarity )
	}
	else
	{
		RuiSetString( equipButtonRui, "buttonText", "#EQUIP_LOOT_REWARD" )
		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( GetCurrentlyEquippedItemNameForItemTypeSlot( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", GetCurrentlyEquippedItemRarityForItemTypeSlot( item ) )

		if ( !Hud_IsVisible( Hud_GetChild( fileLevel.menu, "InspectPurchaseButton" ) ) )
		{
			Hud_SetVisible( fileLevel.equipButton, true )

			if ( ItemFlavor_CanEquipToWheel( item ) )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, true )
			}

			Hud_SetEnabled( fileLevel.equipButton, true )
			Hud_SetLocked( fileLevel.equipButton, false )
		}
	}
}
#endif


#if CLIENT
bool function IsItemEquipped( ItemFlavor item )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item, true )
	foreach ( entry in entries )
	{
		if ( item == LoadoutSlot_GetItemFlavor( LocalClientEHI(), entry ) )
			return true
	}

	return false
}
#endif


#if CLIENT
string function GetCurrentlyEquippedItemNameForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )
	return ItemFlavor_GetLongName( equippedItem )
}
#endif


#if CLIENT
int function GetCurrentlyEquippedItemRarityForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )

	if ( ItemFlavor_HasQuality( equippedItem ) )
		return ItemFlavor_GetQuality( equippedItem )

	return -1
}
#endif


#if CLIENT
void function ClearInspectMenuDetails()
{
	var rui = Hud_GetRui( fileLevel.inspectMenu )
	RuiSetString( rui, "itemType", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "itemName", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "miscText", "" )
	RuiSetInt( rui, "rarity", 0 )
}
#endif


#if CLIENT
void function InspectMenuFunctionality_Model( ItemFlavor item, int displayIndex, int rarity, int quantity, entity model, entity mover, vector startAngles, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( model )
			mover.NonPhysicsStop()
		}
		else
		{
			// weapons should reset rotation so they always appear in a good angle for manipulating
			if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
			{
				HideEntityAndChildren( model )
				mover.NonPhysicsStop()
			}

			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
				{
					if ( itemType == eItemType.weapon_skin )
						PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
					if ( itemType == eItemType.melee_skin )
						PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )

					mover.SetAngles( startAngles )
					mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
					ShowEntityAndChildren( model )
					ModelIntroHighlightEffect( model, rarity, false )
				}
				else if ( itemType == eItemType.character_skin )
				{
					PopulateInspectMenuDetails_CharacterSkin( item, rarity, 1 )
				}
				else if ( itemType == eItemType.account_currency_bundle )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
				}
				else if ( itemType == eItemType.account_currency )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
				}
				else
				{
					PopulateInspectMenuDetails( item, rarity, 1 )
				}

				waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
			}
			else
			{
				HideEntityAndChildren( model )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.SetAngles( startAngles )
		ShowEntityAndChildren( model )
		ModelIntroHighlightEffect( model, rarity, false )

		if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin || itemType == eItemType.account_currency_bundle )
			mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Model( ItemFlavor item, int rarity, int quantity, vector angles, entity mover, entity model, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	if ( itemType == eItemType.weapon_skin )
	{
		PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.melee_skin )
	{
		PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.character_skin )
	{
		PopulateInspectMenuDetails_CharacterSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
	}
	else if ( itemType == eItemType.account_currency )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
	}
	else
	{
		PopulateInspectMenuDetails( item, rarity, quantity )
	}

	waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
}
#endif


const float EXECUTION_START_VIDEO_DELAY = 0.25
const float EXECUTION_START_TURNTABLE_DELAY = 0.15


#if CLIENT
void function InspectMenuFunctionality_Execution( ItemFlavor item, int displayIndex, int rarity, entity attackerModel, entity victimModel, entity mover, vector startAngles )
{
	int itemType                = ItemFlavor_GetType( item )
	var rui                     = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName        = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )
	asset executionVideoAsset   = CharacterExecution_GetExecutionVideo( item )
	string executionVideoString = GetGlobalSettingsString( ItemFlavor_GetAsset( item ), "video" )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( attackerModel )
			HideEntityAndChildren( victimModel )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
				int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
				int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
				int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_VIDEO_DELAY )

				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )

				if ( delayCompleted )
				{
					Hud_SetVisible( fileLevel.inspectVideoPanel, true )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

					int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
					RuiSetInt( rui, "channel", videoChannel )
					StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

					bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

					Hud_SetVisible( fileLevel.inspectVideoPanel, false )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

					ReleaseVideoChannel( videoChannel )

					if ( videoCompleted )
					{
						bool secondDelayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_TURNTABLE_DELAY )

						if ( secondDelayCompleted )
						{
							ShowEntityAndChildren( attackerModel )
							ShowEntityAndChildren( victimModel )

							ModelIntroHighlightEffect( attackerModel, rarity, false )
							ModelIntroHighlightEffect( victimModel, rarity, false )
							mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
							waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
						}
					}
				}
				else
				{
					if ( EffectDoesExist( fxIndexAttacker ) )
						EffectStop( fxIndexAttacker, true, false )

					if ( EffectDoesExist( fxIndexVictim ) )
						EffectStop( fxIndexVictim, true, false )
				}
			}
			else
			{
				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )
			}

			ClearInspectMenuDetails()
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.NonPhysicsStop()
		mover.SetAngles( startAngles )
		ShowEntityAndChildren( attackerModel )
		ShowEntityAndChildren( victimModel )

		ModelIntroHighlightEffect( attackerModel, rarity, false )
		ModelIntroHighlightEffect( victimModel, rarity, false )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Execution( ItemFlavor item, int rarity, entity attackerModel, entity victimModel, entity mover )
{
	int itemType                = ItemFlavor_GetType( item )
	var rui                     = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName        = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )
	asset executionVideoAsset   = CharacterExecution_GetExecutionVideo( item )
	string executionVideoString = GetGlobalSettingsString( ItemFlavor_GetAsset( item ), "video" )

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	wait 1

	int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
	int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
	int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
	int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

	wait EXECUTION_START_VIDEO_DELAY

	HideEntityAndChildren( attackerModel )
	HideEntityAndChildren( victimModel )

	Hud_SetVisible( fileLevel.inspectVideoPanel, true )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

	int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

	bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

	ReleaseVideoChannel( videoChannel )

	wait EXECUTION_START_TURNTABLE_DELAY

	ShowEntityAndChildren( attackerModel )
	ShowEntityAndChildren( victimModel )

	ModelIntroHighlightEffect( attackerModel, rarity, false )
	ModelIntroHighlightEffect( victimModel, rarity, false )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
}
#endif


#if CLIENT
void function ExecutionVideoOnFinished( int channel )
{
	Signal( fileLevel.signalDummy, "LootCeremonyVideoComplete" )
}
#endif


#if CLIENT
void function InspectMenuFunctionality_RUI( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel = null, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			nameText = ItemFlavor_GetShortName( GladiatorCardStatTracker_GetCharacterFlavor( item ) )
			break
	}

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		// hide if not being inspected
		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )

			if ( IsValid( bgModel ) )
				bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()

				ClearInspectMenuDetails()
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )

		if ( IsValid( bgModel ) )
			bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_RUI( ItemFlavor item, int rarity, var rui, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			nameText = ItemFlavor_GetShortName( GladiatorCardStatTracker_GetCharacterFlavor( item ) )
			break
	}

	PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

	WaitForever()
}
#endif


const float QUIP_START_AUDIO_DELAY = 0.25


#if CLIENT
void function InspectMenuFunctionality_Quip( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Quip( ItemFlavor item, int rarity, var rui )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( quipAlias )
		{
			if ( quipAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( quipAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_MusicPack( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText     = ItemFlavor_GetShortName( expect ItemFlavor( MusicPack_GetCharacterOrNull( item ) ) )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_MusicPack( ItemFlavor item, int rarity, var rui )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText = ItemFlavor_GetShortName( item )
	if ( MusicPack_GetCharacterOrNull( item ) != null )
		nameText = ItemFlavor_GetShortName( expect ItemFlavor( MusicPack_GetCharacterOrNull( item ) ) )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( previewAlias )
		{
			if ( previewAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( previewAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity, GladiatorCardData gCardData )
{
	table <string, GladiatorCardData> gCardDataTracker = { data = gCardData }
	OnThreadEnd(
		function() : ( gCardDataTracker )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
		characterName = ItemFlavor_GetShortName( GladiatorCardFrame_GetCharacterFlavor( item ) )
	else
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		// hide if not being inspected
		if ( !activelyInspecting )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
			}
			else
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )

				ClearInspectMenuDetails()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		// show again once inspect is done
		gCardDataTracker.data = ShowRewards_GladiatorCard_Create( item, itemType, false, rarity, origin, angles )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_GladiatorCard( ItemFlavor item, int itemType, int rarity, GladiatorCardData gCardData )
{
	OnThreadEnd(
		function() : ( gCardData )
		{
			ShowRewards_GladiatorCard_Destroy( gCardData )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
		characterName = ItemFlavor_GetShortName( GladiatorCardFrame_GetCharacterFlavor( item ) )
	else
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_FXBeams( int displayIndex, int fxIndexRarity, table<string, int> fxTrackerBeam, int animAttachID, vector rarityColor )
{
	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton    = expect string( results.inspectButton )
		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		// kill fx if not inspecting
		if ( !activelyInspecting )
		{
			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
			else
			{
				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		int newFxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
		EffectSetControlPointVector( newFxIndexBeam, 1, rarityColor )
		fxTrackerBeam[ "fxID" ] = newFxIndexBeam
	}
}
#endif


const float TURNTABLE_MAX_TURN_DEGREES = 360.0
const float TURNTABLE_MAX_PITCH_DEGREES_WEAPON = 60.0


#if CLIENT
void function TurntableModelController( entity model, entity mover, int itemType, entity additionalModel = null, float maxYaw = TURNTABLE_MAX_TURN_DEGREES )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	MenuModelData modelData
	ModelData_SetMover( modelData, mover )
	ModelData_SetBaseAngles( modelData, <0, fileLevel.cameraMover.GetAngles().y + 90, 0> )
	ModelData_SetModel( modelData, model )
	float[2] delta = [0.0, 0.0]
	modelData.rotationDelta[0] = delta[0]
	modelData.rotationDelta[1] = delta[1]

	vector focalPoint = model.GetOrigin()
	float zoomMinDist = 0.0
	float zoomMaxDist = 64.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "MENU_ROTATE" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		focalPoint = GetCharmForWeaponEntity( model ).GetWorldSpaceCenter()
		zoomMinDist = 0.0
		zoomMaxDist = 30.0
	}
	else if ( itemType == eItemType.character_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 64.0
	}
	else if ( itemType == eItemType.character_execution )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		focalPoint = model.GetOrigin()
		zoomMaxDist = 38.0
	}

	CameraZoomData cameraData
	cameraData.mover = fileLevel.cameraMover
	vector camPos = fileLevel.cameraMover.GetOrigin()
	cameraData.startPos = camPos + (Normalize( focalPoint - camPos ) * zoomMinDist)
	cameraData.endPos = camPos + (Normalize( focalPoint - camPos ) * zoomMaxDist)
	cameraData.maxDist = Distance( cameraData.startPos, cameraData.endPos )
	cameraData.normVec = Normalize( cameraData.endPos - cameraData.startPos )

	thread CameraZoomThread( cameraData )

	OnThreadEnd(
		function() : ( model, additionalModel )
		{
			CameraZoomThreadEnd()

			HideEntityAndChildren( model )

			if ( IsValid( additionalModel ) )
				HideEntityAndChildren( additionalModel )

			ClearInspectMenuDetails()
		}
	)

	float maxPitchDegrees = 0.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.weapon_charm || itemType == eItemType.melee_skin )
		maxPitchDegrees = TURNTABLE_MAX_PITCH_DEGREES_WEAPON

	bool hasStopped = false

	while( true )
	{
		bool hasPlayerTurned = TurntableUpdateAnglesFromInput( modelData, maxYaw, maxPitchDegrees, !hasStopped )


		if ( !hasStopped && hasPlayerTurned )
		{
			if ( itemType != eItemType.character_skin )
				mover.NonPhysicsStop()

			hasStopped = true
		}

		WaitFrame()
	}
}
#endif


#if CLIENT
bool function WaitForInspectCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyInspectModeStartComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyInspectModeStartComplete" )
		return true

	return false
}
#endif


#if CLIENT
bool function WaitForInspectTimeCompleteOrBackout( float timeToWait )
{
	thread WaitForTimeComplete( timeToWait )
	array<string> signalsToWait = ["LootCeremonyTimeComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectTimeCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyTimeComplete" )
		return true

	return false
}
#endif


#if CLIENT
bool function WaitForInspectVideoCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyVideoComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectVideoCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyVideoComplete" )
		return true

	return false
}
#endif


#if CLIENT
void function WaitForTimeComplete( float timeToWait )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	wait timeToWait

	Signal( fileLevel.signalDummy, "LootCeremonyTimeComplete" )
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ##     ## ####    #### ##    ## #### ########
//  ##     ##  ##      ##  ###   ##  ##     ##
//  ##     ##  ##      ##  ####  ##  ##     ##
//  ##     ##  ##      ##  ## ## ##  ##     ##
//  ##     ##  ##      ##  ##  ####  ##     ##
//  ##     ##  ##      ##  ##   ###  ##     ##
//   #######  ####    #### ##    ## ####    ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if UI
void function InitLootBoxMenu( var newMenuArg )
{
	var menu = GetMenu( "LootBoxOpen" )
	fileForever.menu = menu
	fileForever.blackFlash = Hud_GetChild( fileForever.menu, "BlackFlash" )

	AddMenuEventHandler( menu, eUIEvent.MENU_OPEN, OnLootBoxMenu_Open )
	AddMenuEventHandler( menu, eUIEvent.MENU_CLOSE, OnLootBoxMenu_Close )
	AddMenuEventHandler( menu, eUIEvent.MENU_NAVIGATE_BACK, OnLootBoxMenu_NavBack )

	AddMenuFooterOption( menu, LEFT, BUTTON_B, true, "#B_BUTTON_BACK", "#B_BUTTON_BACK", null, ShouldShowBackButton )

	// store
	fileForever.storeButton = Hud_GetChild( menu, "StoreButton" )
	HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#STORE_MENU" ) )
	AddButtonEventHandler( fileForever.storeButton, UIE_CLICK, OnClickStoreButton )

	// Open loot box button
	fileForever.lootBoxOpenButton = Hud_GetChild( fileForever.menu, "OpenLootBoxButton" )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "buttonText", Localize( "#OPEN_NEXT_LOOT" ) )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "descText", "" )
	AddButtonEventHandler( fileForever.lootBoxOpenButton, UIE_CLICK, LootBoxOpenAdditional )

	// inspect menu
	fileForever.inspectMenu = Hud_GetChild( fileForever.menu, "InspectBar" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemType", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemName", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "reqsText", "" )

	fileForever.equipButton = Hud_GetChild( fileForever.menu, "InspectEquipButton" )
	HudElem_SetRuiArg( fileForever.equipButton, "buttonText", Localize( "#EQUIP_LOOT_REWARD" ) )
	AddButtonEventHandler( fileForever.equipButton, UIE_CLICK, EquipButtonOnClick )

	fileForever.equipToWheelButton = Hud_GetChild( fileForever.menu, "InspectEquipToWheelButton" )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "buttonText", Localize( "#EQUIP_WHEEL_LOOT_REWARD" ) )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "descText", "" )
	AddButtonEventHandler( fileForever.equipToWheelButton, UIE_CLICK, EquipToWheelButtonOnClick )

	fileForever.purchaseButton = Hud_GetChild( fileForever.menu, "InspectPurchaseButton" )
	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "" )
	AddButtonEventHandler( fileForever.purchaseButton, UIE_CLICK, PurchaseButtonOnClick )

	fileForever.mouseClickElem = Hud_GetChild( fileForever.menu, "ModelRotateMouseCapture" )
	fileForever.inspectVideoPanel = Hud_GetChild( fileForever.menu, "InspectVideoPanel" )

	// loot reward fake buttons
	array<var> inspectRewardButtonArray
	fileForever.inspectRewardButton1 = Hud_GetChild( fileForever.menu, "RewardLeftButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton1 )

	fileForever.inspectRewardButton2 = Hud_GetChild( fileForever.menu, "RewardCenterButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton2 )

	fileForever.inspectRewardButton3 = Hud_GetChild( fileForever.menu, "RewardRightButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton3 )

	foreach ( var button in inspectRewardButtonArray )
	{
		AddButtonEventHandler( button, UIE_CLICK, PreviewButtonOnClick )
		AddButtonEventHandler( button, UIE_GET_FOCUS, PreviewButtonOnHover )
		AddButtonEventHandler( button, UIE_LOSE_FOCUS, PreviewButtonOnLeaveHover )
	}

	// skip animation button
	fileForever.skipAnimButton = Hud_GetChild( fileForever.menu, "SkipAnimationButton" )
	AddButtonEventHandler( fileForever.skipAnimButton, UIE_CLICK, SkipAnimButtonOnClick )

	AddUICallback_OnLevelInit( OnLevelInit )
}
#endif


#if UI
void function LootCeremony_UpdateOpenAdditionalButton()
{
	bool showButton = false

	if ( HasLootBeenPresented() && !IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		if ( GRX_IsInventoryReady() )
		{
			//
			showButton = true
			array<ItemFlavor> specificPackFlavs = []
			if ( fileLevel.forceParticularPackFlav != null )
				specificPackFlavs.append( expect ItemFlavor( fileLevel.forceParticularPackFlav ) )
			UpdateLootBoxButton( fileForever.lootBoxOpenButton, specificPackFlavs )
		}
	}

	Hud_SetVisible( fileForever.lootBoxOpenButton, showButton )
	if ( fileLevel.considerFocusOpenButton )
	{
		fileLevel.considerFocusOpenButton = false
		if ( showButton )
			Hud_SetFocused( fileForever.lootBoxOpenButton )
	}
}
#endif


#if UI
bool function HasLootBeenPresented()
{
	return fileLevel.lootHasBeenPresented
}
#endif


#if UI
void function OnLevelInit()
{
	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
}
#endif


#if UI
void function ClientToUI_SetLootHasBeenPresented()
{
	fileLevel.lootHasBeenPresented = true
	fileLevel.considerFocusOpenButton = true
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, true )
	Hud_SetEnabled( fileForever.storeButton, true )
}
#endif


#if UI
bool function IsInspectModeActive()
{
	return fileLevel.inspectModeActive
}
#endif


#if CLIENT || UI
bool function IsSpecialItemPresentationModeActive()
{
	return fileLevel.specialItemPresentationModeActive
}
#endif


#if UI
void function ClientToUI_SetInspectModeIsActive()
{
	fileLevel.inspectModeActive = true
}
#endif


#if UI
void function ClientToUI_ClearInspectModeIsActive()
{
	fileLevel.inspectModeActive = false
}
#endif


#if UI
void function SetStoreItemPresentationModeActive( GRXScriptOffer grxOffer )
{
	Assert( grxOffer.output.flavors.len() == 1 )

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = grxOffer.output.flavors[0]
	fileLevel.specialItemPresentationModeItemQty = grxOffer.output.quantities[0]
	fileLevel.storeItemPresentationModeItemPrereq = grxOffer.prereq
	fileLevel.specialItemFormattedPrice = GRX_GetFormattedPrice( grxOffer.prices[0], 1 )
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = "#CONFIRM_PURCHASE_WITH"
	fileLevel.specialItemLockPurchaseButton = false
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetBattlePassItemPresentationModeActive( BattlePassReward bpReward )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = bpReward.flav
	fileLevel.specialItemPresentationModeItemQty = bpReward.quantity
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = bpReward.isPremium ? "#BATTLE_PASS_PREMIUM_REWARD" : "#BATTLE_PASS_FREE_REWARD"
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = !(ItemFlavor_GetType( bpReward.flav ) != eItemType.gladiator_card_badge && IsItemFlavorEquippable( bpReward.flav ))
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = Localize( "#BATTLE_PASS_LEVEL_REQUIRED", bpReward.level + 1 )
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetGenericItemPresentationModeActive( ItemFlavor itemFlav, string priceHeader, string subHeader )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = subHeader
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = priceHeader
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetCollectionEventItemPresentationModeActive( ItemFlavor flav, GRXScriptOffer ornull grxOffer, string ornull packName, asset ornull packImg )
{
	string priceText = ""
	if ( grxOffer != null )
	{
		expect GRXScriptOffer(grxOffer)
		array<string> formattedPrices
		foreach ( ItemFlavorBag price in grxOffer.prices )
			formattedPrices.append( GRX_GetFormattedPrice( price, 1 ) )

		if ( formattedPrices.len() == 1 )
			priceText = Localize( "#STORE_PRICE_N", formattedPrices[0] )
		else if ( formattedPrices.len() == 2 )
			priceText = Localize( "#STORE_PRICE_N_N", formattedPrices[0], formattedPrices[1] )
	}

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = flav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = priceText
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = (grxOffer == null)
	fileLevel.specialItemPriceHeader = "#PURCHASE"
	fileLevel.specialItemLockPurchaseButton = (grxOffer == null)
	fileLevel.specialItemPackName = packName
	fileLevel.specialItemPackImg = packImg

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetChallengeRewardPresentationModeActive( ItemFlavor itemFlav, int itemQty, string priceHeader, string subHeader, bool isComplete )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = itemQty
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = subHeader
	fileLevel.specialItemOverrideOwned = isComplete
	fileLevel.specialItemHideEquipButton = !(ItemFlavor_GetType( itemFlav ) != eItemType.gladiator_card_badge && IsItemFlavorEquippable( itemFlav ))
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = priceHeader
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

#endif


#if UI
bool function InspectItemTypePresentationSupported( ItemFlavor item )
{
	switch ( ItemFlavor_GetType( item ) )
	{
		case eItemType.account_currency_bundle:
		case eItemType.account_pack:
		case eItemType.character_skin:
		case eItemType.character_execution:
		case eItemType.weapon_skin:
		case eItemType.weapon_charm:
		case eItemType.melee_skin:
		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
		case eItemType.gladiator_card_stat_tracker:
		case eItemType.gladiator_card_badge:
		case eItemType.music_pack:
		case eItemType.loadscreen:
			return true

		case eItemType.account_currency:
			return ItemFlavor_GetAsset( item ) != $"settings/itemflav/grx_currency/crafting.rpak" //
	}

	return false
}
#endif

// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ##     ## ####     #######  ########  ######## ##    ##     ######  ##        #######   ######  ########
//  ##     ##  ##     ##     ## ##     ## ##       ###   ##    ##    ## ##       ##     ## ##    ## ##
//  ##     ##  ##     ##     ## ##     ## ##       ####  ##    ##       ##       ##     ## ##       ##
//  ##     ##  ##     ##     ## ########  ######   ## ## ##    ##       ##       ##     ##  ######  ######
//  ##     ##  ##     ##     ## ##        ##       ##  ####    ##       ##       ##     ##       ## ##
//  ##     ##  ##     ##     ## ##        ##       ##   ###    ##    ## ##       ##     ## ##    ## ##
//   #######  ####     #######  ##        ######## ##    ##     ######  ########  #######   ######  ########
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if UI
void function OnLobbyOpenLootBoxMenu_ButtonPress( ItemFlavor ornull forceParticularPackFlav = null )
{
	fileLevel.forceParticularPackFlav = forceParticularPackFlav
	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}
#endif


#if UI
void function OnLootBoxMenu_Open()
{
	UI_SetPresentationType( ePresentationType.INACTIVE )
	thread LootCeremonyFlashScreenBlack_Internal()

	HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packName", "" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", $"", eRuiArgType.IMAGE )

	if ( IsSpecialItemPresentationModeActive() )
	{
		AddCallbackAndCallNow_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		AddCallbackAndCallNow_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		SpecialItemPresentationSequenceUI()
		LootCeremony_UpdateOpenAdditionalButton()
	}
	else
	{
		Hud_SetVisible( fileForever.purchaseButton, false )
		Hud_SetEnabled( fileForever.purchaseButton, false )

		AddCallbackAndCallNow_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
		thread LootBoxOpenSequenceUI( true )
	}
}
#endif


#if UI
void function OnLootBoxMenu_Close()
{
	fileLevel.forceParticularPackFlav = null
	if ( IsSpecialItemPresentationModeActive() )
	{
		fileLevel.specialItemPresentationModeActive = false
		RunClientScript( "UIToClient_SpecialItemPresentationExit" )

		RemoveCallback_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		RemoveCallback_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		fileLevel.specialItemPresentationModeActive = false
		fileLevel.storeItemPresentationModeOffer = null
		//
		fileLevel.specialItemPresentationModeItemQty = -1
		fileLevel.storeItemPresentationModeItemPrereq = null
		fileLevel.specialItemFormattedPrice = ""
		fileLevel.specialItemOverrideOwned = null
		fileLevel.specialItemHideEquipButton = false
		fileLevel.specialItemHidePurchaseButton = false
		fileLevel.specialItemPriceHeader = ""
		fileLevel.specialItemLockPurchaseButton = false
	}
	else
	{
		RunClientScript( "UIToClient_LootCeremonyExit" )
		RemoveCallback_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
	}
}
#endif


#if UI
bool function ShouldShowBackButton()
{
	if ( IsSpecialItemPresentationModeActive() )
		return true

	return HasLootBeenPresented()
}
#endif


#if UI
void function OnClickStoreButton( var button )
{
	var lobbyMenu = GetMenu( "LobbyMenu" )

	CloseActiveMenu()
	AdvanceMenu( lobbyMenu )
	TabData tabData = GetTabDataForPanel( lobbyMenu )
	//ActivateTab( tabData, Tab_GetTabIndexByBodyName( tabData, "StorePanel" ) )
}
#endif


#if UI
void function OnLootBoxMenu_NavBack()
{
	if ( !HasLootBeenPresented() && !IsSpecialItemPresentationModeActive() )
		return

	if ( IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		RunClientScript( "UIToClient_RewardInspectNavBack" )
		return
	}

	CloseActiveMenu()
}
#endif


#if UI
void function LootBoxOpenAdditional( var button )
{
	thread LootBoxOpenSequenceUI( false )
}
#endif


#if UI
void function EquipButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipOnClick" )
}

void function ClientToUI_EquipButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item )

	//
	OpenSelectSlotDialog( entries, item, GetItemFlavorAssociatedCharacterOrWeapon( item ),
				(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipOnClickWithIndex", index )
		})
	)
}

void function EquipToWheelButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipToWheelOnClick" )
}

void function ClientToUI_EquipToWheelButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	array<LoadoutEntry> entries = []

	ItemFlavor character = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( item ) )

	for ( int i = 0; i < MAX_QUIPS_EQUIPPED; i++ )
	{
		LoadoutEntry entry = Loadout_CharacterQuip( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
		{
			entries.append( entry )
		}
	}

	//
	OpenSelectSlotDialog( entries, item, character,
				(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipToWheelOnClickWithIndex", index )
		})
	)
}
#endif


#if UI
void function PurchaseButtonOnClick( var button )
{
	if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
		{
			ConfirmDialogData dialogData
			dialogData.headerText = "#STORE_REQUIREMENTS_FAILED"
			dialogData.messageText = Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) )
			dialogData.contextImage = $"ui/menu/common/dialog_notice"

			OpenOKDialogFromData( dialogData )

			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
			return
		}
	}

	if ( fileLevel.storeItemPresentationModeOffer != null )
	{
		PurchaseDialogConfig pdc
		pdc.offer = fileLevel.storeItemPresentationModeOffer
		PurchaseDialog( pdc )
	}
	else
	{
		PurchaseDialogConfig pdc
		pdc.flav = fileLevel.specialItemPresentationModeItemFlav
		PurchaseDialog( pdc )
	}
}
#endif


#if UI
void function PreviewButtonOnClick( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardInspectActivate", button )
}
#endif


#if UI
void function PreviewButtonOnHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, true )
}
#endif


#if UI
void function PreviewButtonOnLeaveHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, false )
}
#endif


#if UI
void function LootBoxOpenSequenceUI( bool firstTime )
{
	fileLevel.lootHasBeenPresented = false
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	// Get the actual rewards
	ItemFlavor ornull pack
	if ( fileLevel.forceParticularPackFlav )
	{
		pack = fileLevel.forceParticularPackFlav
	}
	else
	{
		pack = GetNextLootBox()
	}
	Assert( pack != null )
	expect ItemFlavor( pack )
	int quality = ItemFlavor_GetQuality( pack )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )

	if ( firstTime )
	{
		RunClientScript( "UIToClient_EnterLootCeremony", ItemFlavor_GetGUID( pack ) )
	}
	else
	{
		RunClientScript( "UIToClient_AdditionalLootTick_Sequence", ItemFlavor_GetGUID( pack ) )
	}

	ScriptGRXOperationInfo operation
	operation.expectedQueryGoal = GRX_HTTPQUERYGOAL_OPEN_PACK
	operation.doOperationFunc = (void function( int opID ) : ( pack ) {
		printt( "GRX_OpenPack", opID, ItemFlavor_GetGRXIndex( pack ) )
		GRX_OpenPack( opID, ItemFlavor_GetGRXIndex( pack ) )
	})
	operation.onDoneCallback = (void function( int status ) : ( operation ) {
		if ( status == eScriptGRXOperationStatus.DONE_SUCCESS )
			RunClientScript( "UIToClient_OnGRXPackOpeningResultsAvailable" )
		else
			CloseActiveMenu()
	})
	QueueGRXOperation( GetUIPlayer(), operation )
}
#endif


#if UI
void function SpecialItemPresentationSequenceUI()
{
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
	RunClientScript( "UIToClient_SpecialItemPresentation", ItemFlavor_GetGUID( fileLevel.specialItemPresentationModeItemFlav ), fileLevel.specialItemPresentationModeItemQty )
	//

	UpdateSpecialItemPresentationPurchaseButton()
}

void function ClientToUI_UpdateSpecialItemPresentationPurchaseButton()
{
	UpdateSpecialItemPresentationPurchaseButton()
}
#endif


#if UI
void function UpdateSpecialItemPresentationPurchaseButton()
{
	if ( !IsSpecialItemPresentationModeActive() )
		return

	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", fileLevel.specialItemPriceHeader )
	HudElem_SetRuiArg( fileForever.purchaseButton, "descText", fileLevel.specialItemFormattedPrice )

	bool isOfferUnavailable = false
	if ( fileLevel.storeItemPresentationModeOffer != null && !(expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).isAvailable )
	{
		isOfferUnavailable = true
		HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "#UNAVAILABLE" )
		string unavailableReason = (expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).unavailableReason
		HudElem_SetRuiArg( fileForever.purchaseButton, "descText", unavailableReason != "#UNAVAILABLE" ? unavailableReason : "" )
	}
	else if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
	}

	ItemFlavor itemFlav = fileLevel.specialItemPresentationModeItemFlav

	bool showPurchase = false
	bool showEquip    = false

	if ( GRX_IsInventoryReady() )
	{
		if ( TEMP_IsItemFlavorEquippable( itemFlav ) )
		{
			bool isOwned = false
			if ( fileLevel.specialItemOverrideOwned != null )
				isOwned = expect bool(fileLevel.specialItemOverrideOwned)
			else if ( ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.REGULAR )
				isOwned = GRX_IsItemOwnedByPlayer( itemFlav, null )

			//
			if ( itemFlav == GetItemFlavorByAsset( $"settings/itemflav/gcard_badge/account/season02_bplevel.rpak" ) )
				isOwned = GladiatorCardBadge_DoesStatSatisfyValue( itemFlav, 110 )

			if ( !fileLevel.specialItemHidePurchaseButton )
				showPurchase = !isOwned

			if ( !fileLevel.specialItemHideEquipButton )
				showEquip = isOwned
		}
		//
		//
		//
		//
		else if ( fileLevel.storeItemPresentationModeOffer != null )
		{
			showPurchase = !GRXOffer_IsFullyClaimed( expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer) )
		}
	}

	Hud_SetVisible( fileForever.purchaseButton, showPurchase )
	Hud_SetEnabled( fileForever.purchaseButton, !fileLevel.specialItemLockPurchaseButton && !isOfferUnavailable )
	Hud_SetLocked( fileForever.purchaseButton, fileLevel.specialItemLockPurchaseButton || isOfferUnavailable )

	Hud_SetVisible( fileForever.equipButton, showEquip )
	Hud_SetEnabled( fileForever.equipButton, true )
	Hud_SetLocked( fileForever.equipButton, false )

	if ( showPurchase || showEquip )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", true )
	}

	if ( fileLevel.specialItemPackName != null && showPurchase )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", true )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packName", expect string(fileLevel.specialItemPackName) )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", expect asset(fileLevel.specialItemPackImg), eRuiArgType.IMAGE )
	}

	if ( ItemFlavor_GetType( itemFlav ) == eItemType.weapon_charm && showEquip )
	{
		Hud_SetEnabled( fileForever.equipButton, false )
		Hud_SetLocked( fileForever.equipButton, true )

		HudElem_SetRuiArg( fileForever.equipButton, "buttonText", "#UNLOCKED" )
		HudElem_SetRuiArg( fileForever.equipButton, "descText", "#CHARM_EQUIP_INSTRUCTIONS" )
		HudElem_SetRuiArg( fileForever.equipButton, "descTextRarity", eQuality.COMMON )
	}
}
#endif

const float BLACK_FADE_TIME = 0.25
const float BLACK_FADE_TIME_HOLD = 0.25


#if UI
void function LootCeremonyFlashScreenBlack_Internal()
{
	Hud_SetAlpha( fileForever.blackFlash, 255 )
	Hud_Show( fileForever.blackFlash )
	wait BLACK_FADE_TIME_HOLD
	Hud_FadeOverTime( fileForever.blackFlash, 0, BLACK_FADE_TIME, INTERPOLATOR_ACCEL )
	wait BLACK_FADE_TIME
	Hud_Hide( fileForever.blackFlash )
}
#endif


#if UI
void function ClientToUI_PlayLootCeremonySound( string alias )
{
	EmitUISound( alias )
}
#endif


#if UI
void function ClientToUI_StopLootCeremonySound( string alias )
{
	StopUISoundByName( alias )
}
#endif


#if UI
void function SkipAnimButtonOnClick( var button )
{
	RunClientScript( "UIToClient_SkipAnimation" )
}
#endif


#if UI
void function ClientToUI_LootCeremonyMarkItemAsNoLongerNew( SettingsAssetGUID itemFlavorGUID )
{
	ItemFlavor item = GetItemFlavorByGUID( itemFlavorGUID )
	Newness_IfNecessaryMarkItemFlavorAsNoLongerNewAndInformServer( item )
}
#endif


// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
//
//  ##     ## ####     ######   ########  ##     ##
//  ##     ##  ##     ##    ##  ##     ##  ##   ##
//  ##     ##  ##     ##        ##     ##   ## ##
//  ##     ##  ##     ##   #### ########     ###
//  ##     ##  ##     ##    ##  ##   ##     ## ##
//  ##     ##  ##     ##    ##  ##    ##   ##   ##
//   #######  ####     ######   ##     ## ##     ##
//
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================
// ==========================================================================================================================


#if UI
ItemFlavor ornull function GetNextLootBox()
{
	ItemFlavor ornull nextPack = null

	table<ItemFlavor, int> packCountMap = GRX_GetPackCounts()

	int highestQuality = 0
	foreach ( ItemFlavor pack, int count in packCountMap )
	{
		int quality = ItemFlavor_GetQuality( pack )
		if ( count == 0 || quality <= highestQuality )
			continue

		highestQuality = quality
		nextPack = pack
	}

	return nextPack

}
#endif


#if CLIENT || UI 
//Voidwalker Event Bundle
ItemFlavor function TEMP_GetVoidwalkerBundle()
{
	return GetItemFlavorByAsset( $"settings/itemflav/pack/cosmetic_event_season02_event02_wraith.rpak" )
}
#endif